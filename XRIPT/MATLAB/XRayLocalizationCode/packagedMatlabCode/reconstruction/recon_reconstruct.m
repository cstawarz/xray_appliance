function [expectedCalibratedSystem, centerPoints, residual, resnorm, iters, exitflag] =...
    recon_reconstruct(expectedCalibratedSystem, RHS)

%% recon_reconstruct is the reconstruction module when RHS is known, for
%% stationary system
%
% [expectedCalibratedSystem, centerPoints, resnorm, iters, exitflag] =
% ...recon_reconstruct(expectedCalibratedSystem, RHS)
%
% general reconstruction module:
% Reconstruction is the process of finding the location of fiducials 
% (or an electrode, represented as a fiducial)
% in space, given some expected system geometry and a set of 2d feature points from x-ray images. 
% It is assumed that the XRAYSystem has been calibrated before reconstruction. 
% The function provided can be used by a system with n detectors, provided it is stationary.
% The basic idea of reconstruction, is that fiducials are perturbed in space for a particular 
% x-ray system geometry, until the expect projections match the actual projections,
% as acquired by feature extraction. 
%
% 
% Expects RHS with correct correspondences. Will converge to a poor value
% otherwise.
% reconstructs expected system with levenberg marquardt according to
% optmization options.
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Input:
%
% expectedCalibratedSystem  is our assumed system after calibration.
%
% RHS is a vector of extracted features (or a struct with extracted features, see readme.doc)
% from images of the fiducials. The ordering of extracted feature points determines the order of centerPoints
% output. 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Output:
%
% expectedCalibratedSystem: system after reconstruction- it will have
% reconstructed fiducials in it, rather than the calibration object.
%
% centerPoints: n*3 array of the reconstructed 3d centers of the fiducials we have imaged (or electrode), 
% ordered in the same order as the RHS that was passed in (see RHS format within Feature Extraction)
% 
% resnorm: the norm of the residual of the reconstruction-
% this can give some idea of how good our reconstruction is- it should be small.
% 
% ExitFlag: indicates whether reconstruction converged. If it didn’t we have a very bad reconstruction.
% 
% Iters: how many iterations reconstruction took.
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Requires: 
% expectedCalibrated system has as many detectors as there were
% in the system that formed the RHS
%
% Correspondences implicit to RHS must be correct
% 
% modifies:
% expected system to have fiducial layout corresponding to
% reconstruction. Removes any calibration object or other fiducials
% already in expectedCalibratedSystem.


%%debug output
displ = 1;

%%checking whether input is nested struct format, struct or vector format. If struct or nested struct,
%convert to vector form
RHS = xrg_RHSVerbose2Vector(RHS);

numberOfFiducials = size(RHS,1)/(expectedCalibratedSystem.getNumberOfSDP()*2);
xrg_emptySystem(expectedCalibratedSystem); %% emptying the system just in case

xrg_addFiducials1(expectedCalibratedSystem, numberOfFiducials); %%adding random fiducials, 5000 delta


%% if the RHS has invalid values for the expectedSystem-
%% negative values, or values large than dimension of one of the arrays, 
%% throw an error. 
if (~Simulator.OutputGenerator.outputInBounds(RHS, expectedCalibratedSystem))  
   RHS
    'rhs size'
    size(RHS,1)
    'availableData'
    expectedCalibratedSystem.availableData(1)
    error('invalid values in RHS.');
end

%%checking size of RHS
if(size(RHS,1)~= expectedCalibratedSystem.availableData(1))
    'rhs size'
    size(RHS,1)
    'availableData'
    expectedCalibratedSystem.availableData(1)
    error('malformatted data passed into recon_reconstruct- wrong size, check to see that',...
            'expected calibrated system has correct number of fiducials and detectors');
end

%%reconOutputSimulator variable needs to be global, so that the numerical methods can call
%%the function we are minimizing (calcF) without any parameters other than
%%X. reconOutputSimulator encapsulates any parameters in the
%%function.
global reconOutputSimulator
reconOutputSimulator = Simulator.ReconStatStatUnknown(expectedCalibratedSystem, RHS);

%%Uses the init guess for fiducial positions 
%% generated by the recon_outputSimulator.
%% The guess is a vector of fiducial positions that places
%%fiducials near ray intersections
 guess = reconOutputSimulator.generateGuess();
% guess = reconOutputSimulator.getSampleInput();

%%function we are minimizing
fun = @calcF;

if(displ)
    showIterations = 'iter';
else
    showIterations = 'off';
end

%%options for the minimization - uses levenberg marquardt
options = optimset('Display',showIterations,'LargeScale','off', 'LevenbergMarquardt', 'on', 'MaxFunEvals', 1000000,... %%1000000 functional evaluations
'TolFun', 10^-15, 'TolCon', 10^-15, 'MaxIter', 300); %%10000 iterations max

%% calling numerical method here
[x,resnorm,residual,exitflag,output] = ...
    lsqnonlin(fun,... %%function we are minimizing
    guess,... %%initGuess
    [],... %%lowerBounds
    [],... %%upperBounds
    options); %%convergence criteria, numerical options
%%x
iters = output.iterations;

%% getting center points after we've reconstructed
centerPoints = xrg_getFiducialCenters(expectedCalibratedSystem);
end

%%the function we minimize- funcitional parames other than X are stored in
%%reconOutputSimulator
function F = calcF(X)
    global reconOutputSimulator
    F = reconOutputSimulator.calcF(X); 
end

