//TODO: comment, specfields

/*
 * Source.java
 * Created on Sep 29, 2004
 * By Daniel Oreper
 */

/**
 * @OVERVIEW:
 * 
 * This class represents an xRay source. 
 * It is normally used within the SourceDetectorPairClass, to match it up with a corresponding detector.
 * 
 * Source can be used to model a point source, or a source with some radius. getRay returns a ray from 
 * the center of the source, and is used to model a point source, while getRays returns a collection of 
 * rays to approximate the rays generated by a source with some radius
 *
 * Inheritance information: It extends TransformableObject and is self-moving.
 */

/**
 * @specfield radius: float radius of the source
 * @specfield center: present center of the source
 */

package Simulator;

import java.util.ArrayList;
import java.util.Iterator;

import javax.vecmath.Point3d;
import javax.vecmath.Vector3d;


public class Source extends TransformableObject
{    
	
    //TODO: add intensity field? maybe not needed as relative brightness doesnt matter
	private double radius;
	private Point3d initDAcenter;
	
	
	//SHould be local, optimizing
	private Point3d center = new Point3d();
	private Ray myRay;
	private Vector3d myVector;
	
    private Source(Point3d initCenter, Point3d initDetectorArrayCenter)
    {
    		super(initCenter); 
// 		System.out.println(initCenter);
    		//System.out.println("poo");
    		this.initDAcenter = initDetectorArrayCenter;
    }
    
    private Source(Point3d initCenter, Point3d initDetectorArrayCenter, double radius)
    {
    		super(initCenter); 
    		//System.out.println("poo");
    		this.initDAcenter = initDetectorArrayCenter;
    		this.radius = radius;
    }
    
    protected static Source Build(Point3d initCenter, Point3d initArrayCenter)
    {
        Source s = new Source(initCenter, initArrayCenter);
        BasisCollection initOrientation = s.createInitOrientation(initArrayCenter);
//        System.out.println("wrong init");
//        BasisCollection initOrientation = s.createInitOrientation();
        s.setInitOrientation(initOrientation);

        Vector3d axis1 = initOrientation.getB2();
        axis1.scale(-1); //this is the azimuthal axis, but the b2 basis is pointing down
        s.setInitAxis1(axis1); //b2! important 
        s.setInitAxis2(initOrientation.getB1()); //b1! important
        s.setInitAxis3(initOrientation.getB3());
        s.setInitBasis1(initOrientation.getB1());
        s.setInitBasis2(initOrientation.getB2()); 
        s.setInitBasis3(initOrientation.getB3());     
        
        return s;
    }
    
    
    protected static Source Build(Point3d initCenter, Point3d initArrayCenter, double radius)
    {
        Source s = new Source(initCenter, initArrayCenter, radius);
        BasisCollection initOrientation = s.createInitOrientation(initArrayCenter);
        s.setInitOrientation(initOrientation);
        s.setInitBasis1(initOrientation.getB1());
        s.setInitBasis2(initOrientation.getB2()); 
        s.setInitBasis3(initOrientation.getB3());     
        return s;
    }
    
    
    private BasisCollection createInitOrientation()
    {
        BasisCollection bc;
        
        Point3d normalPoint = getInitDetectorArrayCenter(); //clones the point
        normalPoint.sub(this.getInitCenter());
        Vector3d normal = new Vector3d(normalPoint);
        
        Vector3d b3 = normal;
        Vector3d b1 = new Vector3d(0,0,-1);
        Vector3d b2 = new Vector3d();
        b2.cross(b1, b3);
        
        bc = new BasisCollection(b1, b2, b3, getInitCenter());
        return bc;   
    }
    
    private BasisCollection createInitOrientation(Point3d arrayCenter)
    {
        //TODO: change to w respect to initCenter?
        //normal is built w respect to init centers
        Point3d sourceCenter = this.getInitCenter();
        Point3d arrayClon = (Point3d)arrayCenter.clone();
        sourceCenter.sub(arrayClon);
       
        Vector3d normal = new Vector3d(sourceCenter);
//        Vector3d normal = new Vector3d(-1,0,0);
        if (normal.length()==0)
        {
            throw new RuntimeException("Bad normal passed into createInitOrientation");
        }
        normal.normalize();
    	
    		Vector3d basis1;
    		Vector3d basis2;
    		Vector3d basis3;
    		
    		if (normal.x < 0)
    		{
    		    if(normal.y < 0)
    		    {
    		        basis1 = new Vector3d(normal.y/normal.x, -1, 0);
    		    }
    		    else if (normal.y ==0)
    		    {
    		        basis1 = new Vector3d(0, -1, 0);
    		    }
    		    else 
    		    {
    		        basis1 = new Vector3d(normal.y/normal.x, -1, 0);
    		    }
    		}
    		else if (normal.x == 0)
    		{
    		    if(normal.y < 0)
    		    {
    		        basis1 = new Vector3d(1, 0, 0);
    		    }
    		    else if (normal.y ==0)
    		    {
    		        if (normal.z<0)
    		        {
    		            basis1 = new Vector3d(1, 0, 0);
    		        }
    		        else if (normal.z==0)
    		        {
    		            throw new RuntimeException("bad vector passed into init orientation");
    		        }
    		        else 
    		        {
    		            basis1 = new Vector3d(-1, 0, 0);
    		        }
    		    }
    		    else 
    		    {
    		        basis1 = new Vector3d(-1, 0, 0);
    		    }
    		}
    		else 
    		{
    		    if(normal.y < 0)
    		    {
    		        basis1 = new Vector3d(-normal.y/normal.x, 1, 0);
    		    }
    		    else if (normal.y ==0)
    		    {
    		        basis1 = new Vector3d(0, 1, 0);
    		    }
    		    else 
    		    {
    		        basis1 = new Vector3d(-normal.y/normal.x, 1, 0);
    		    }
    		}
        
        basis1.normalize();
        // To get B2, we take cross product of B1 and the normal, and then normalize
        
        basis2 = new Vector3d();
        basis2.cross(basis1, normal);
        basis2.normalize();
        
        //B3 is the negative normal
        basis3 = ((Vector3d)normal.clone());
        basis3.normalize();
        
        BasisCollection bc = new BasisCollection(basis1, basis2, basis3, getInitCenter());
        return bc;
    }

    /**
     * 
     * @param p
     * @modifies: super.getCenter() gets most recent location information => call to super.recalculate()
     * see TransformableObject for list of modified variables and effects associated with call to recalculate()
     * 
     * @effects: see Transformable object for state changes associated with recalculate.
     * @return a unit ray from the center of the source to the Point p;
     */
    public Ray getRay(Point3d p)
    {	
       
        getCenter(center);
       
    		Ray r = this.getRayFromTo(center, p);
    		
    		return r;
    }
    
   public void getRay(Point3d p, Ray r)
    {
    		this.getRayFromTo(getCenter(), p, r);
    }
    
    public Point3d getInitDetectorArrayCenter()
    {
        return (Point3d)initDAcenter.clone();
    }
    
    //TODO: make circular rather than square?
    /**
     * 
     * @param p: point to which we want a ray
     * 
     * @modifies:  super.getCenter() gets most recent location information => call to super.recalculate()
     * see TransformableObject for list of modified variables and effects associated with call to recalculate()
     * 
     * @effects: see Transformable object for state changes associated with recalculate.
     *  
     * @return:
     * If we make a 3*3*3 cube grid centered at source center, 
     * with cubes of length radius, one unit ray is created from the center
     * of each cube, to the point p 
     * This collection of unit rays from the grid centers to the point p is returned. 
     * This is in effect an approximation for the fact that the source is not a point.
     */
    public ArrayList getRays(Point3d p)
    {
    		ArrayList rays = new ArrayList();
    		Point3d src = this.getCenter();
    		//System.out.println(src);
    		src.x = src.x - radius;
    		src.y = src.y - radius;
    		src.z = src.z - radius;
    		
    		for (int i=0; i<3; i++)
    		{
    			for (int j=0; j<3; j++)
    			{
    				for (int k=0; k<3; k++)
    				{
    				    //creating a new point for every ray
    				    Point3d miniSource = new Point3d(src.x+i*radius, src.y+j*radius, src.z+k*radius);
    					Ray r = getRayFromTo(miniSource, p);
    					//System.out.println(r);
    					rays.add(r);
    				}
    			}
    		}
    		
    		return rays;
    }
    
    public void getRays(Point3d p, ArrayList rays)
    {
    		rays.clear();
    		Point3d src = this.getCenter();
    		src.x = src.x - radius;
    		src.y = src.y - radius;
    		src.z = src.z - radius;
    		
    		for (int i=0; i<3; i++)
    		{
    			for (int j=0; j<3; j++)
    			{
    				for (int k=0; k<3; k++)
    				{
    				    Point3d miniSource = new Point3d(src.x+i*radius, src.y+j*radius, src.z+k*radius);
    					Ray r = getRayFromTo(miniSource, p);
    					rays.add(r);
    				}
    			}
    		}
    }
    
    //creates a ray from src to dest
    private Ray getRayFromTo(Point3d src, Point3d dest)
    {
    		Vector3d direction = new Vector3d(dest.x-src.x, dest.y-src.y, dest.z-src.z);
    		direction.normalize();
    		Ray r = new Ray(src, direction);
    		return r;
    }
    
////  creates a ray from src to dest
    private void getRayFromTo(Point3d src, Point3d dest, Ray r)
    {
    		dest.sub(src);
    		r.getDirection().set(dest);
    		r.getDirection().normalize();
    		r.getStartPoint().set(src);
   }
    
    /**
     * @return String representation of a source
     * @effects: super.toString() gets most recent location information => call to super.recalculate(). 
     * see Transformable object for state changes associated with recalculate. 
     */
    public String toString()
    {
    		String s = "";
    		
    		s = s + "Source: " +"\n";
    		s = s + super.toString();
    		s = s + "Radius: " + radius + "\n"; 
    		s = s + "\n";
    		return s;
    }
    
//    public String tobjectProperties()
//    {
//        String s = "";
//        s = s + "Source: " + "\n";
//        s = s + "Radius: " + radius + "\n";
//        s = s + super.tobjectProperties();
//        return s;
//    }
    
    /**
     * @param d
     * @effects:
     * sets the x displacement of the local trajectory of the source to be d.
     */
    public void setTranslationToDetectorArray(double d)
    {
    		super.setInitTranslation3(d);
    }
   
    
    /**
     * @param d
     * @effects:
     * sets the y axis displacement of the local trajectory of the source to be d.
     */
    public void setHorizontalTranslation(double d)
    {
    		super.setInitTranslation2(d);
    }
   

    /**
     * @param d
     * @effects:
     * sets the z displacement of the local trajectory of the source to be d.
     * This change cannot be observed in the center displacement, 
     * until a get method that calls recalculate  is called.
     */
    public void setVerticalTranslation(double d)
    {
    		this.setInitTranslation1(d);
    }
    
    /**
     * @ return: deepClone of this source
     */
    public Object clone()
    {
    		//getInitCenter returns a copy, so this is in effect a deep clone
    		return new Source(this.getInitCenter(), this.initDAcenter);
    }
    
    public double getRadius()
    {
        	return radius;
    }
    
    public void setRadius(double radius)
    {
        this.radius = radius;
    }
    
    public static void main(String[] args)
    {
        //XRAYSystem actual = new XRAYSystem();
        HeavyFiducial f1 = HeavyFiducial.BuildFiducial(new Point3d(0,0,0),10,2,3,0);
        Source s = Source.Build(new Point3d(-10,0,0), new Point3d(10,0,0));
        s.setRadius(1);
        ArrayList arrs = s.getRays(f1.getCenter());
        Iterator iter = arrs.iterator();
        while (iter.hasNext())
        {
            Ray r= (Ray) iter.next();
            System.out.println(r);
        }
    }
}
    
 
