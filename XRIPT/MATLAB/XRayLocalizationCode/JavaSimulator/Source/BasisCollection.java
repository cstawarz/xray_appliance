/* * BasisCollection.java * Created on Oct 6, 2004 * By Daniel Oreper */package Simulator;import javax.media.j3d.Transform3D;import javax.vecmath.Matrix3d;import javax.vecmath.Point3d;import javax.vecmath.Tuple3d;import javax.vecmath.Vector3d;/** *  * @author Daniel Oreper * Created on Nov 19, 2004 */public class BasisCollection{    /**     * @OVERVIEW: This class represents an orientation of a rigid body by storing its coordinate frame     * This frame includes the set of bases and an origin.     *      * The primary method of use is toNew, which given a point in the standard x,y,z reference frame     * will return a point given in the coordinates of the BC reference frame.     *      * An object can model a changing refernce frame by calling transformBasis(Transform3d)     * for example if an object is changed by a transform3d that is a rotation about the z axis, the BC can also be      * transformed by a rotation about the z axis      */    private Vector3d b1; //basis vector 1 of new coordinate system    private Vector3d b2; //basis vector 2 of new coordinate system    private Vector3d b3; //basis vector 3 of new coordinate system    private Point3d origin;    private Matrix3d newCoordinates; //matrix to tranform to new coordinates    private Matrix3d oldCoordinates; //matrix to transform point in new coordinate system back to standard     //(x', y', z')-> (x, y, z)        public BasisCollection(Vector3d b1, Vector3d b2, Vector3d b3, Point3d origin)    {        this.b1 = b1;        this.b2 = b2;        this.b3 = b3;        b1.normalize();        b2.normalize();        b3.normalize();        this.origin = origin;        oldCoordinates = new Matrix3d();        oldCoordinates.setColumn(0, b1);        oldCoordinates.setColumn(1, b2);        oldCoordinates.setColumn(2, b3);        //System.out.println(oldCoordinates);        newCoordinates = (Matrix3d)oldCoordinates.clone();        try         {            		newCoordinates.invert();        }        catch(Exception e)        {            System.out.println(e);            System.out.println("basis1:");            System.out.println(b1);            System.out.println("basis2:");            System.out.println(b2);            System.out.println("basis3:");            System.out.println(b3);            throw new RuntimeException("Badly formed orientation, uninvertible matrix");        }    }        public BasisCollection()    {        this.b1 = new Vector3d(1,0,0);        this.b2 = new Vector3d(0,1,0);        this.b3 = new Vector3d(0,0,1);        b1.normalize();        b2.normalize();        b3.normalize();        this.origin = new Point3d();        oldCoordinates = new Matrix3d();        oldCoordinates.setColumn(0, b1);        oldCoordinates.setColumn(1, b2);        oldCoordinates.setColumn(2, b3);        //System.out.println(oldCoordinates);        newCoordinates = (Matrix3d)oldCoordinates.clone();        try         {            		newCoordinates.invert();        }        catch(Exception e)        {            System.out.println(e);            System.out.println(b1);            System.out.println(b2);            System.out.println(b3);            throw new RuntimeException("Badly formed orientation");        }    }        //    /** //     * //     *return a basis collection s.t.//    * p1 is origin, basis1 is normalized vector from p1 to p2 //     basis2 is normalized projection of vector from p1 to//    * to p3 onto basis1, and basis3 is normalized //    * cross product of basis1 and basis2//    *  /    public static BasisCollection BuildOrthoUnitBasisCollection(Point3d p1, Point3d p2, Point3d p3)    {        //todo: speedup by getting rid of clones?        Point3d origin = p1;        Point3d temp = (Point3d)p1.clone();        temp.sub(p2);        temp.scale(-1);        Vector3d b1 = new Vector3d(temp);        b1.normalize();                temp = (Point3d)p1.clone();        temp.sub(p3);        temp.scale(-1);        Vector3d b2 = new Vector3d(temp);//        System.out.println(b2);//        System.out.println(b1);        double scale = b1.dot(b2);        //        b2.scaleAdd(-scale, b1); //getting the orthogonal component of b2: b2 = b2- (b1 dot b2)*b1        b2.scaleAdd(-scale, b1, b2);       // System.out.println(b2);        b2.normalize();              Vector3d b3 = new Vector3d();                b3.cross(b1,b2);        b3.normalize();                        return new BasisCollection(b1, b2, b3, origin);    }        public Point3d toNew(Point3d oldPoint)    {        Point3d newPoint = (Point3d)oldPoint.clone();        newPoint.sub(origin);        newCoordinates.transform(newPoint);        return newPoint;    }        public void toNew(Tuple3d oldPoint, Tuple3d newPoint)    {       //System.out.println("basis is");        //System.out.println(this);        //System.out.println("oldpoint is");        //System.out.println(oldPoint);        newPoint.set(oldPoint);        newPoint.sub(origin);        //System.out.println(newPoint);                        newCoordinates.transform(newPoint);        //System.out.println("new point is");        //System.out.println(newPoint);                //        System.out.println("newPoint is");//        System.out.println(newPoint);//        System.out.println(newCoordinates);        //return newPoint;    }        public Point3d toOld(Point3d newPoint)    {        Point3d oldPoint = (Point3d)newPoint.clone();               oldCoordinates.transform(oldPoint);                oldPoint.add(origin);        return oldPoint;    }        public void transformBasis(Transform3D t)    {    		//System.out.println(t);    				t.transform(b1);		t.transform(b2);		t.transform(b3);		t.transform(origin);		oldCoordinates.setColumn(0, b1);		oldCoordinates.setColumn(1, b2);		oldCoordinates.setColumn(2, b3);		newCoordinates.set(oldCoordinates);		try{		    newCoordinates.invert();		}		catch(RuntimeException e)		{		    System.out.println(b1);		    System.out.println(b2);		    System.out.println(b3);		    System.out.println(t);		    throw e;		}    }    //deepclone!!    public Object clone()    {    		return new BasisCollection(    		        (Vector3d)b1.clone(),    		        (Vector3d)b2.clone(),    		        (Vector3d)b3.clone(),    		        (Point3d)origin.clone());    }        public void set(BasisCollection bc)    {        this.b1.set(bc.b1);        this.b2.set(bc.b2);        this.b3.set(bc.b3);        this.origin.set(bc.origin);        this.oldCoordinates.setColumn(0, b1);        this.oldCoordinates.setColumn(1, b2);        this.oldCoordinates.setColumn(2, b3);        //System.out.println(oldCoordinates);        this.newCoordinates.set(oldCoordinates);        try         {            		newCoordinates.invert();        }        catch(Exception e)        {            System.out.println(e);            System.out.println(b1);            System.out.println(b2);            System.out.println(b3);            throw new RuntimeException("Badly formed orientation");        }    }        public String toString()    {    		String s = "";    		s += "Basis1 is: " + b1 +"\n";    		s += "Basis2 is: " + b2 +"\n";    		s += "Basis3 is: " + b3 +"\n";    		s += "Origin is: " + origin +"\n";    		//s += "To New Matrix is: " + "\n" + this.newCoordinates +"\n";    		//s += "To Old Matrix is: " + "\n" + this.oldCoordinates +"\n";    		return s;    }        public static void main(String[] args)    {    		Point3d p1 = new Point3d(0,0,0);    		Point3d p2 = new Point3d(2,0,0);    		Point3d p3 = new Point3d(1,5,0);    		BasisCollection bc = BasisCollection.BuildOrthoUnitBasisCollection(p1,p2,p3);    		System.out.println(bc);    }        	/**	 * @return Returns the b1.	 */	public Vector3d getB1() 	{		return (Vector3d)b1.clone();	}		/**	 * @return Returns the b2.	 */	public Vector3d getB2()	{		return (Vector3d)b2.clone();	}		/**	 * @return Returns the b3.	 */	public Vector3d getB3() 	{		return (Vector3d)b3.clone();	}		//TODO: get rid of this? or add specfield normal?	/**	 * @return b3	 */	public Vector3d getNormal()	{		Vector3d nrm = getB3();		nrm.scale(-1);		return nrm;	}			public void getNormal(Vector3d normal)	{		normal.set(b3);	}				/**	 * @return Returns the origin.	 */	public Point3d getOrigin() 	{		return (Point3d)origin.clone();	}}