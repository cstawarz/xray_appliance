//TODO: specfields, overview//TODO get rid of totalLength etc,/* * DetectorArray.java * Created on Sep 17, 2004 * By Daniel Oreper */package Simulator;import javax.vecmath.*;import java.awt.*;import java.util.ArrayList;import java.util.Iterator;public class DetectorArray extends TransformableObject{     private double pixelWidth;    private double pixelHeight;    private int rows;    private int columns;    private double totalLength;    private double totalHeight;    private double[][] exposures;    private Point3d initSourceCenter;            //Should be local to getPhysicalIntersection- optimization for speed to avoid reallocating    private double widthInverse;    private double heightInverse;    private Vector3d centerVector = new Vector3d();    private Point3d centerPoint = new Point3d();    private Point3d projectedPoint = new Point3d();    private Vector3d normal = new Vector3d();    private Vector3d srcVector = new Vector3d();    private double tolerance = Math.pow(10, -6);    //private Point exposedPoint = new Point();            private DetectorArray(int rows,            int columns,             double pixelHeight,            double pixelWidth,            Point3d initCenter)    {    		super(initCenter);//creating a default transformableObject    		this.initSourceCenter = initSourceCenter;    		this.rows=rows;        this.columns=columns;        this.exposures = new double[rows][columns];        this.pixelWidth = pixelWidth;        this.widthInverse = 1/pixelWidth;        this.pixelHeight = pixelHeight;        this.heightInverse = 1/pixelHeight;        this.totalHeight = rows * pixelHeight;        this.totalLength = columns * pixelWidth;     }    //we need static constructor because of java language limitations-    //call to set orientation cannot be made in a constructor, as the super object    //does not exist yet    protected static DetectorArray Build(int rows,            int columns,             double pixelHeight,            double pixelWidth,            Point3d initCenter,            Point3d initSourceCenter)    {        DetectorArray det = new DetectorArray(rows,                columns,                pixelHeight,                pixelWidth,                initCenter);                BasisCollection initOrientation = det.createInitOrientation(initSourceCenter);        det.setInitOrientation(initOrientation);                Vector3d axis1 = initOrientation.getB2();        axis1.scale(-1); //this is the azimuthal axis, but the b2 basis is pointing down        det.setInitAxis1(axis1); //b2! important         det.setInitAxis2(initOrientation.getB1()); //b1! important        det.setInitAxis3(initOrientation.getB3());        det.setInitBasis1(initOrientation.getB1());        det.setInitBasis2(initOrientation.getB2());         det.setInitBasis3(initOrientation.getB3());                     return det;    }        /**     *      * @return: new DA. s.t.     * DA.rows = 1000,     * DA.columns = 1024,     * DA.pixelWidth = 48,     * DA.pixelHeight = 48,     * DA.initCenter = center,     * DA.center = center,     * DA.normal = Vector from s.initCenter to DA.initCenter     * DA.PolarRotation = 0,     * DA.Azimuthalrotation = 0,     * DA.NormalRotation = 0     */    protected static DetectorArray BuildDefault(Point3d center, Point3d sourceCenter)    {        //System.out.println("Building Default Array2");    		return Build(1000, 1024, 48, 48, center, sourceCenter);    }            public Point3d getInitSourceCenter()    {        return (Point3d)initSourceCenter.clone();    }    /**     * @requires: source and detector are not at the same point     * @effects: initializes orientation of DA     */        //creates orietnation for a DA such that it is facing the negative x axis,    //basis1 toward the x axis, basis 2 downward and basis 3 from left to right (-y axis)        private BasisCollection createInitOrientation()    {    		Vector3d basis1 = new Vector3d(0,-1,0);    		Vector3d basis2 = new Vector3d(0, 0, -1);    		Vector3d basis3 = new Vector3d(1,0,0);    		//Now to get the origin coordinate- the top left of the detector array    		//moving from center to left    		Point3d origin = new Point3d();    		Point3d temp= new Point3d(basis1); //point form of basis vec used to move left    		temp.scale(this.totalLength/2);    		origin.sub(getInitCenter(), temp);    		    		//now moving from left to top    		temp = new Point3d(basis2); //point form of basis vec used to move up    		temp.scale(this.totalHeight/2);    		origin.sub(origin, temp);    		    		BasisCollection initOrientation = new BasisCollection(basis1, basis2, basis3, origin);    		return initOrientation;    }        private BasisCollection createInitOrientation(Point3d sourceCenter)    {         	//TODO: change to w respect to initCenter?        //normal is built w respect to init centers    		Point3d srcclon = (Point3d)sourceCenter.clone();        srcclon.sub(this.getInitCenter());        Vector3d normal = new Vector3d(srcclon);//        System.out.println(normal);//        Vector3d normal = new Vector3d(-1,0,0);         if (normal.length()==0)        {            throw new RuntimeException("Bad normal passed into initializeOrientation");        }        normal.normalize();    	    		Vector3d basis1;    		Vector3d basis2;    		Vector3d basis3;    		    		if (normal.x < 0)    		{    		    if(normal.y < 0)    		    {    		        basis1 = new Vector3d(normal.y/normal.x, -1, 0);    		    }    		    else if (normal.y ==0)    		    {    		        basis1 = new Vector3d(0, -1, 0);    		    }    		    else     		    {    		        basis1 = new Vector3d(normal.y/normal.x, -1, 0);    		    }    		}    		else if (normal.x == 0)    		{    		    if(normal.y < 0)    		    {    		        basis1 = new Vector3d(1, 0, 0);    		    }    		    else if (normal.y ==0)    		    {    		        if (normal.z<0)    		        {    		            basis1 = new Vector3d(1, 0, 0);    		        }    		        else if (normal.z==0)    		        {    		            throw new RuntimeException("bad vector passed into init orientation");    		        }    		        else     		        {    		            basis1 = new Vector3d(-1, 0, 0);    		        }    		    }    		    else     		    {    		        basis1 = new Vector3d(-1, 0, 0);    		    }    		}    		else     		{    		    if(normal.y < 0)    		    {    		        basis1 = new Vector3d(-normal.y/normal.x, 1, 0);    		    }    		    else if (normal.y ==0)    		    {    		        basis1 = new Vector3d(0, 1, 0);    		    }    		    else     		    {    		        basis1 = new Vector3d(-normal.y/normal.x, 1, 0);    		    }    		}    		basis1.normalize();        // To get B2, we take cross product of B1 and the normal, and then normalize            		basis2 = new Vector3d();        basis2.cross(basis1, normal);        basis2.normalize();                //B3 is the normal        basis3 = ((Vector3d)(normal.clone()));        basis3.scale(-1);        basis3.normalize();             //Now to get the origin coordinate- the top left of the detector array        //moving from center to to left        Point3d origin = new Point3d();        Point3d temp= new Point3d(basis1); //point form of basis vec used to move left        temp.scale(this.totalLength/2);        origin.sub(getInitCenter(), temp);                //now moving from left to top        temp = new Point3d(basis2); //point form of basis vec used to move up        temp.scale(this.totalHeight/2);        origin.sub(origin, temp);                BasisCollection initOrientation = new BasisCollection(basis1, basis2, basis3, origin);//        System.out.println(initOrientation);        return initOrientation;    }        /**     *      * @requires intersects(r) is true     * returns intersection in general physical space of the intersection of the ray with the detector     * @param r     */    public Point3d getPhysicalIntersection(Ray r)     {    		super.getNormal(normal);		this.getCenter(centerPoint); 		this.centerVector.set(centerPoint);		//TODO change rep of ray to take care of this		Vector3d src = new Vector3d(r.getStartPoint());		Vector3d direction = r.getDirection();		//direction.normalize();				centerVector.sub(src);		double denominator = normal.dot(direction);		double numerator = normal.dot(centerVector);				direction.scale(numerator/denominator);		direction.add(src);				//System.out.println(direction);		return new Point3d(direction);	}        /**     *      * @return Detector indices of the detector pixel intersected by r.     * If there is no intersection, return null     */    private Point getDetectorIntersectionDiscrete(Ray r)    {        Point3d physical = getPhysicalIntersection(r);        return physicalToDetectorDiscrete(physical);     }    /**     *      * @return coordinate in detector array reference frame,      * of the intersection of the array with r     * If there is no intersection return null;     */    public Point2d getDetectorIntersectionContinuous(Ray r)    {                Point3d physical = getPhysicalIntersection(r);               return physicalToDetectorContinuous(physical);             }    public Point2d getDetectorIntersectionContinuous2(Ray r)    {                Point3d physical = getPhysicalIntersection(r);               return physicalToDetectorContinuous2(physical);             }            //requires: only called on points actually on the detector array    private Point physicalToDetectorDiscrete(Point3d physical)    {    		//TODO: use contains eventually    	        getOrientation().toNew(physical, physical);    		//Point3d newPhysical = getOrientation().toNew(physical); //converting to detector array basis space        int xIndex;        int yIndex;                xIndex = continuousToDiscrete(physical.x, 0, pixelWidth);         yIndex = continuousToDiscrete(physical.y, 0, pixelHeight);	   				               if((xIndex>columns-1)||(xIndex<0)||(yIndex>rows-1)||(yIndex<0))		{			return null;		}        return new Point(xIndex, yIndex);    }        /**     * modifies discrete point rather than allocating a new one.      * @param physical     * @param discrete     * @return     */    private Point physicalToDetectorDiscrete(Point3d physical, Point discrete)    {    		//TODO: use contains eventually    	    		Point3d newPhysical = getOrientation().toNew(physical); //converting to detector array basis space        int xIndex;        int yIndex;    		xIndex = continuousToDiscrete(newPhysical.x, 0, pixelWidth);     		yIndex = continuousToDiscrete(newPhysical.y, 0, pixelHeight);	    				        if((xIndex>columns-1)||(xIndex<0)||(yIndex>rows-1)||(yIndex<0))		{			return null;		}                return new Point(xIndex, yIndex);    }        /**     *      * @return coordinate in the      */    private Point2d physicalToDetectorContinuous(Point3d physical)    {        //System.out.println("getting new");    		//getOrientation().toNew(physical, physical); //converting to detector array basis space    		Point3d newPhysical = getOrientation().toNew(physical);    		//testing to make sure we are on detector plane    		int zIndex = continuousToDiscrete(physical.z, 0, 1);        //double zOrigin = orientation.getOrigin().z;        //if (newPhysical.z != 0)        //careful here may be incorrect!        if (Math.abs(newPhysical.z)>Math.pow(10, -6))        {        		//we are not on detector array        		System.out.println(physical);        		System.out.println(newPhysical);            throw new RuntimeException("getDiscreteDetectorIntersection called on a point not on the detector");        }                //System.out.println(physical);        //testing to make sure we are within range of detector plane        int xIndex = continuousToDiscrete(newPhysical.x, 0, pixelWidth);         int yIndex = continuousToDiscrete(newPhysical.y, 0, pixelHeight);	        //        if(yIndex == 0)//        {//            throw new RuntimeException("neg val");//        }//        					if((xIndex>columns-1)||(xIndex<0)||(yIndex>rows-1)||(yIndex<0))		{		    //System.out.println("projecting off of arrayh");		    //System.out.println(this);		    //System.out.println(physical);		    //System.out.println(xIndex);		    //System.out.println(yIndex);			//null indicates we are off of the detector array			return null;		}		        return new Point2d(newPhysical.x/this.pixelWidth,                 newPhysical.y/pixelHeight);    }        private Point2d physicalToDetectorContinuous2(Point3d physical)    {    		Point3d newPhysical = getOrientation().toNew(physical);        //careful here may be incorrect!        if (Math.abs(newPhysical.z)>Math.pow(10, -6))        {        		//we are not on detector array        		System.out.println(physical);        		System.out.println(newPhysical);            throw new RuntimeException("getDiscreteDetectorIntersection called on a point not on the detector");        }   		     return new Point2d(newPhysical.x/this.pixelWidth,                 newPhysical.y/pixelHeight);    }        protected void physicalToDetectorContinuous2(Tuple3d physical, BasisCollection orientation, Tuple2d detectorContinuous)    {	        //System.out.pr        //converting to detector array basis space        //System.out.println("old is");        //System.out.println(physical);    		orientation.toNew(physical, physical);    		//System.out.println("new is");    		//System.out.println(physical);    		//Point3d newphysical = orientation.toNew(new Point3d(physical));    		//System.out.println(orientation);    		//testing to make sure we are on detector plane        //careful here may be incorrect!        if (Math.abs(physical.z)>tolerance)        {        		//we are not on detector array        		//System.out.println(physical);            System.out.println("new is");        		System.out.println(physical);        		//System.out.println(newPhysical);            throw new RuntimeException("getDiscreteDetectorIntersection called on a point not on the detector");        }	        detectorContinuous.set        (physical.x*widthInverse, physical.y*heightInverse);    }        /**     *      * @param physical     * @param start     * @param discretization     * @returns index of the physical quantity, given the start point, discretizatoin.     **/    private int continuousToDiscrete(double physical, double start, double discretization)    {        double rng = physical - start;        int indx = (int)Math.ceil(rng/discretization)-1;        return indx;    }         //returns: the point at the center of indxth discretization, i.e. start + (indx +.5)*discretization    //requires: the object that is discretized has a length that is a multiple of discretization    private double discreteToContinuous(int indx, double start, double discretization)      {    		return (start + (indx + .5) * discretization);    }        /**     *      * @return Point at the center of the detectorPanel indexed by detector coordinate     */    public Point3d detectorToPhysical(Point2d detectorCoordinate)    {    		    		    		//TODO: input checking        //TODO: implement    		//get the y coordinate within the array of the detector we looking for        double relativeY = pixelHeight*detectorCoordinate.y;         //get x coordinate        double relativeX = pixelWidth*detectorCoordinate.x;        //z coordinate is by definition 0 since we are right on the array        double relativeZ = 0;        //The coordinates of the point in the array coordinate sytem:        Point3d p = new Point3d(relativeX, relativeY, relativeZ);        Point3d oldP = getOrientation().toOld(p);        return oldP;    }        public double[][] getExposures()    {    		return (double[][])exposures.clone();    		//return exposures;    }        public void wipeClean()    {    		for (int i=0; i<this.rows; i++)    		{    			for (int j=0; j<columns; j++)    			{    				exposures[i][j]=0;    			}    		}    }        /**     * @modifies: exposures     * @effects: projected upon pixel elements within exposures are increased by      * radiation     */    public void expose1(Ray r, double radiation)    {        		if (radiation==0)        		{        		    return;        		}    			Point p = this.getDetectorIntersectionDiscrete(r);    			//we are off of the detector array    			if (p==null)    			{    				return;    			}    			exposures[p.y][p.x] += radiation;    }            public void project2(Fiducial f, Source src, int numVoxels)    {        Vector3d normal = this.getNormal();        BasisCollection orientation = this.getOrientation();        Point3d fidCenter = f.getCenter();        double radius = f.getRadius();        double voxelProjectionSize= (radius/(numVoxels-.5));                 Ray ray;        double attenuation = f.getFiducialAttenuation();        for (int i=0; i<2*numVoxels-1; i++)        {            for (int j=0; j<2*numVoxels-1; j++)            {                for (int k=0; k<2*numVoxels-1; k++)                {                    projectedPoint.set((i+.5)*voxelProjectionSize + fidCenter.x - radius,                            					(j+.5)*voxelProjectionSize + fidCenter.y - radius,                            					(k+.5)*voxelProjectionSize + fidCenter.z - radius);                                        double distanceToCenter = projectedPoint.distance(fidCenter);                                        if(distanceToCenter>radius)                    {                         	//do nothing                                            }                    else                    {                        ray = src.getRay(projectedPoint);                        this.expose2(ray, attenuation);                    }                }            }        }    }        public void project3(Fiducial f, Source src, int numVoxels)    {        Vector3d normal = this.getNormal();        BasisCollection orientation = this.getOrientation();        Point3d fidCenter = f.getCenter();        double radius = f.getRadius();        double voxelProjectionSize= (radius/(numVoxels-.5));         ArrayList rays;        Iterator rayIter;        //Ray ray;        int attenuation = (int)f.getFiducialAttenuation();        for (int i=0; i<2*numVoxels-1; i++)        {            for (int j=0; j<2*numVoxels-1; j++)            {                for (int k=0; k<2*numVoxels-1; k++)                {                    projectedPoint.set((i+.5)*voxelProjectionSize + fidCenter.x - radius,                            					(j+.5)*voxelProjectionSize + fidCenter.y - radius,                            					(k+.5)*voxelProjectionSize + fidCenter.z - radius);                                        double distanceToCenter = projectedPoint.distance(fidCenter);                                        if(distanceToCenter>radius)                    {                         	//do nothing                                            }                    else                    {                        //System.out.println(projectedPoint);                        rays = src.getRays(projectedPoint);                        //System.out.println(projectedPoint);                        rayIter = rays.iterator();                        while (rayIter.hasNext())                        {                            Ray ray = (Ray) rayIter.next();                            //System.out.println(ray);                            //System.out.println(projectedPoint);                            this.expose2(ray, attenuation);                        }                    }                }            }        }    }        public double getNormalAngle()    {    		return this.getRotation3();    }            public double getAzimuthalAngle()    {       return this.getRotation2();    }        public double getPolarAngle()    {        return this.getRotation1();    }        //TODO: test this method!!!!    //TODO: speed it up if need be    /**     * @modifies: exposures     * @effects: certain elements within exposures are increased by some multiple of radiation     * See Exposures model for clarification     */    public void expose2(Ray r, double radiation)    {			        		if (radiation==0)			{            		return;			}	    		Point2d p = this.getDetectorIntersectionContinuous(r);			//we are off of the detector array			if (p==null)			{				return;			}									int roundedX = (int)Math.round(p.x);			int roundedY = (int)Math.round(p.y);						//10^-6 is a magic number!!!			//Are we on x boundary?			boolean xBoundary = Math.abs(roundedX - p.x) < Math.pow(10, -6);						//are we on leftmost x boundary?			boolean leftMost = (roundedX == 0);						//Are we on y boundary?			boolean yBoundary = Math.abs(roundedY - p.y) < Math.pow(10, -6);						//are we on topmost?			boolean topMost = (roundedY == 0);						//TODO: get rid of floor			//case where we arent on a boundary			if (!xBoundary && !yBoundary)			{			    int yIndx = (int) Math.floor(p.y);			    int xIndx = (int) Math.floor(p.x);//			    if (yIndx<0||xIndx<0)//			    {//			        throw new RuntimeException("bad indices");//			    }			    exposures[yIndx][xIndx] += radiation;			    return;			}			//			case where we are on x Boundary and it does matter			if(xBoundary && !yBoundary && !leftMost)			{			    int yIndx = (int)Math.floor(p.y);			    int xIndx = (int)Math.round(p.x);			    	exposures[yIndx][xIndx] += radiation/2;			    	exposures[yIndx][xIndx-1] += radiation/2;			    	return;			} 						//case where we are on y Boundary, and it does matter			if (!xBoundary && yBoundary && !topMost) 			{			    int yIndx = (int)Math.round(p.y);			    int xIndx = (int)Math.floor(p.x);			    	exposures[yIndx][xIndx] += radiation/2;			    	exposures[yIndx-1][xIndx] += radiation/2;			    	return;			}						//case where we are on yBoundary, but it doesnt matter since we are in topmost area			if (!xBoundary && yBoundary && topMost) 			{			    int yIndx = (int)Math.round(p.y);			    int xIndx = (int)Math.floor(p.x);			    	exposures[yIndx][xIndx] += radiation;			    	return;			}						//case where we are on xBoundary, but it doesnt matter since we are in leftmost area			if(xBoundary && !yBoundary && leftMost)			{			    int yIndx = (int)Math.floor(p.y);			    int xIndx = (int)Math.round(p.x);			    	exposures[yIndx][xIndx] += radiation;			}						//case where we are on both x Boundary and yBoundary, but x Boundary doesnt matter			if(xBoundary && yBoundary && leftMost && !topMost)			{			    int yIndx = (int)Math.round(p.y);			    int xIndx = (int)Math.round(p.x);				exposures[yIndx][xIndx] += radiation/2;		    		exposures[yIndx-1][xIndx] += radiation/2;		    		return;			}						//case where we are on both xBoundary and yBoundary. but yBoundary doesnt matter			if(xBoundary && yBoundary && !leftMost && topMost)			{			    int yIndx = (int)Math.round(p.y);			    int xIndx = (int)Math.round(p.x);				exposures[yIndx][xIndx] += radiation/2;		    		exposures[yIndx][xIndx-1] += radiation/2;		    		return;			}						//			case where we are on both xBoundary and yBoundary and it does matter for both			if(xBoundary && yBoundary && !leftMost && !topMost)			{			    int yIndx = (int)Math.round(p.y);			    int xIndx = (int)Math.round(p.x);				exposures[yIndx][xIndx] += radiation/4;		    		exposures[yIndx][xIndx-1] += radiation/4;		    		exposures[yIndx-1][xIndx] += radiation/4;			    	exposures[yIndx-1][xIndx-1] += radiation/4;			    	return;			}						//case where we are on both xBoundary and YBoundary, but neither matters 			if(xBoundary && yBoundary && leftMost && topMost)			{ 			    int yIndx = (int)Math.round(p.y);			    int xIndx = (int)Math.round(p.x);			    exposures[yIndx][xIndx] += radiation;			    return;			}					}          public Vector3d getNormal()    {    		return super.getNormal();    }        public Point3d getOrigin()    {        return getOrientation().getOrigin();    }        /**     *      * @return pixelWidth     */    public double getPixelWidth()    {    		return this.pixelWidth;    }        /**     * @return Returns the number of columns.     */    public int getColumns()    {        return columns;    }    /**     * @return Returns the rows.     */    public int getRows()    {        return rows;    }    /**     *      * @return pixelHeight     */    public double getPixelHeight()    {    		return this.pixelHeight;    }        /**     * @return String representation of detector array:      * center, normal, center of 0,0 pixel, physical origin of array.     */    public String toString()    {    		String s = "";    		s = s + "Detector Array: " + "\n";    		s = s + super.toString();    		//s = s + "Actual Center is: " + getCenter() + "\n";    		s = s + "Actual Normal is: " + getNormal() + "\n";    		s = s + "Top left is: " + detectorToPhysical(new Point2d(.5,.5)) + "\n";    		s = s + "Origin is: " + getOrigin() + "\n";    		s = s + "\n";    		//s = s + "Detector width is: " + "\n" + this.pixelWidth + "\n";    		//s = s + "Basis collection: " + "\n" + this.getOrientation() + "\n";   	    		//s = s +"\n";    		//s = s + "InitBasisCollection: " +"\n";    		//s = s + initBC;    		//s = s + "Trajectory is: " + "\n" + this.actualArrayTrajectory +"\n";    		return s;    }               /**     * sets the rotation delta about the polar axis of the detector     * @param d     */    public void setRotationAboutPolar(double d)    {    		this.rotateAboutInitAxis1(d);    }    /**     * sets the rotation delta about the azimuthal axis of the detector     * @param d     */    public void setRotationAboutAzimuthal(double d)    {    		this.rotateAboutInitAxis2(d);    }        /**     * sets the rotation delta about the normal axis of the detector     * @param d     */    public void setRotationAboutNormal(double d)	{    		this.rotateAboutInitAxis3(d);	}            //TODO: rename as x translation??    //tranlation in direction of basis1    public void setTranslationHorizontal(double d)    {    		super.setInitTranslation1(d);    }        public double getTranslationHorizontal()    {    		return super.getTranslation1();    }    //  TODO: rename as y translation??    //translation in directoin of basis2    public void setTranslationVertical(double d)    {    		super.setInitTranslation2(d);    }        public double getTranslationVertical()    {    		return super.getTranslation2();    }    //  TODO: rename as z translation??    //tranlastion in direction of basis3    public void setTranslationFromSource(double d)    {    		super.setInitTranslation3(d);    }        public double  getNormalTranslation()    {    		return super.getTranslation3();    }  }