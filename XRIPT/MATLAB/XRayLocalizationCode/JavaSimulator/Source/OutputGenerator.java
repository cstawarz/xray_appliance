/* * Created on May 12, 2005 * */package Simulator;import javax.vecmath.Point3d;/** * @author Daniel Oreper * Created on May 12, 2005 */public abstract class OutputGenerator{    /**     * @     */    protected XRAYSystem expectedSystem;        protected double[] actualValues;    protected double[] expectedOutput;    protected double[] fOutput;    protected boolean simulated;    //public abstract double[] generateGuess();    public abstract double[] calcExpected(double[] X);    public abstract double[] calcF(double[] X);    public abstract int getRequiredInputSize();    public abstract int getRequiredOutputSize();    public abstract double[] getSampleInput();    //public abstract String describeInputNoFiducials(double[] X);        /**     * @effects- throws exception if finds nan or infinity passed in as an input     */    public void checkInput(double[] X)    {        for (int i= 0; i< X.length; i++)        {            double element= X[i];            boolean b = Double.isInfinite(element)||Double.isNaN(element);            if(b)            {                OutputGenerator.printArray(X);                throw new RuntimeException("Infinite or NaN values in the array");            }        }    }        public OutputGenerator(XRAYSystem expectedSystem, double[] actualValues)    {        if (actualValues!=null)        {            if(outputInBounds(actualValues, expectedSystem))            {                //System.out.println("not null");                this.actualValues = actualValues;                expectedOutput = new double[actualValues.length];                fOutput = new double[actualValues.length];                this.expectedSystem = expectedSystem;                //this.expectedSystem.reCenter();                simulated = false;                         }            else            {                throw new RuntimeException("out of bounds values passed in");            }        }        else        {           throw new RuntimeException("null actualValues passed in");        }    }        public OutputGenerator(XRAYSystem expectedSystem, double[] actualValues, boolean checkValues)    {        if (actualValues==null)        {            throw new RuntimeException("null actualValues passed in");        }        if(checkValues)        {            if(!outputInBounds(actualValues, expectedSystem))            {                throw new RuntimeException("out of bounds values passed in");            }        }        this.actualValues = actualValues;        expectedOutput = new double[actualValues.length];        fOutput = new double[actualValues.length];        this.expectedSystem = expectedSystem;        //this.expectedSystem.reCenter();        simulated = false;                 }            /**     * @ return string rep of expectedSystem     */    public String toString()    {        //System.out.println("calling toString");        System.out.println("actualValues");        OutputGenerator.printArray(actualValues);        return this.expectedSystem.toString();        }       /**    * print to screen a string rep of a    *     * @param a    */       /**     * @effects: prints an input array a to the screen     * Used for testing purposes     */   protected static void printArray(double[] a)   {       //System.out.println("calling printarray");       String s = "";       for (int i = 0; i < a.length; i++)       {           s = s + a[i] + "\n";       }       System.out.println(s);   }      	/**   	 *    	 * @return: this simulated   	 */    public boolean isSimulatedData()    {        return simulated;    }        /**     * @effects: this.simulated = true     *     */    public void setSimulatedData()    {        this.simulated = true;    }        /**     * @effects: this.simulated = false     *     */    public void setUnsimulatedData()    {        this.simulated = false;    }        /**     *      * @return true if os has actualValues set     */    public boolean hasActualValues()    {        return (actualValues != null);    }    /**     *      * @param data     * @return true if none of the data is outside of detector bounds     * Takes into account multiple detectors with different pixel dimensions      * as well as multiple rootations     */    public boolean outputInBounds(double data[])    {        //System.out.println("checking bounds");        if (data == null)        {            throw new RuntimeException(                    "empty data passed into OutputSimulator.inBounds");        }         int numberOfPairs = expectedSystem.getNumberOfSDP();                //A shot is an instant when one or more xrays are fired        double numberOfShots = data.length/ (expectedSystem.availableData(1));         if (Math.rint(numberOfShots) != numberOfShots)        {            throw new RuntimeException("malformated data passsed into inBoundsCheck");        }                boolean inside = true;        for (int shot = 0; shot < numberOfShots; shot++)        {            for (int sdp = 0; sdp < numberOfPairs; sdp++)            {                //TODO: replace this call with                // expectedSystem.getDetectorWidth(sdp);                int columns = (int) expectedSystem.getSDP(sdp).getDetector()                        .getColumns();                //TODO: replace this call with                // expectedSystem.getDetectorHeight(sdp);                int rows = (int) expectedSystem.getSDP(sdp).getDetector()                        .getRows();                int offset = (shot * expectedSystem.availableData(1))                        + (sdp * expectedSystem.dataPerArray());                for (int i = 0; i < expectedSystem.dataPerArray(); i = i + 2)                {                    //outside the furthest bounds of detector array                    if (data[offset + i] > columns)                    {                        inside = false;                    }                    if (data[offset + i + 1] > rows)                    {                        inside = false;                    }                    //outside smallest boubds of detector array                    if (data[offset + i] < 1)                    {                        inside = false;                    }                    if (data[offset + i + 1] < 1)                    {                        inside = false;                    }                }            }        }        if (inside == false)        {            //System.out.println("OUT OF BOUNDS!");            //OutputGenerator.printArray(data);        }        return inside;    }        public static boolean outputInBounds(double data[], XRAYSystem expectedSystem)    {        //System.out.println("checking bounds");        if (data == null)        {            throw new RuntimeException(                    "empty data passed into OutputSimulator.inBounds");        }         int numberOfPairs = expectedSystem.getNumberOfSDP();                //A shot is an instant when one or more xrays are fired        double numberOfShots = data.length/ (expectedSystem.availableData(1));         if (Math.rint(numberOfShots) != numberOfShots)        {            throw new RuntimeException("malformated data passsed into inBoundsCheck");        }                boolean inside = true;        for (int shot = 0; shot < numberOfShots; shot++)        {            for (int sdp = 0; sdp < numberOfPairs; sdp++)            {                //TODO: replace this call with                // expectedSystem.getDetectorWidth(sdp);                int columns = (int) expectedSystem.getSDP(sdp).getDetector()                        .getColumns();                //TODO: replace this call with                // expectedSystem.getDetectorHeight(sdp);                int rows = (int) expectedSystem.getSDP(sdp).getDetector()                        .getRows();                int offset = (shot * expectedSystem.availableData(1))                        + (sdp * expectedSystem.dataPerArray());                for (int i = 0; i < expectedSystem.dataPerArray(); i = i + 2)                {                    //outside the furthest bounds of detector array                    if (data[offset + i] > columns)                    {                        inside = false;                    }                    if (data[offset + i + 1] > rows)                    {                        inside = false;                    }                    //outside smallest boubds of detector array                    if (data[offset + i] < 1)                    {                        inside = false;                    }                    if (data[offset + i + 1] < 1)                    {                        inside = false;                    }                }            }        }        if (inside == false)        {            System.out.println("OUT OF BOUNDS!");            //OutputGenerator.printArray(data);        }        return inside;            }        public void setActualValues(double[] actualValues)    {        //System.out.println("setting");//        if(!outputInBounds(actualValues)||actualValues.length!=getRequiredOutputSize())//        {//            throw new RuntimeException("invalid actualValues passed in to setValues");   //        }        //else        //{        for (int i =0; i<actualValues.length;i++)        {            this.actualValues[i] = actualValues[i];        }        //}    }        public void setExpectedSystem(XRAYSystem expectedSystem)    {        this.expectedSystem = expectedSystem;    }            /**     * @efffects: mutates data s.t. if any elements are outside of      * range where they ought to be, they are moved inside. For example, if a max value      * is 1000, and actualData contains 1005, this value is changed to 1000.     * If the distance is more than 10 at any point, runtime exception throw to indicate something     * drastically wrong with data.     *      * Used only with simulatedData     * @param data     */    //TODO: test fixOutput methods    protected void fixOutput(double[] data)    {        if (!simulated)        {            throw new RuntimeException(                    "Fixing real data! Fixing data should only occur "                            + "when dealing with simulated data");        }        System.out.println("fixing faulty simulated data");        if (data == null)        {            throw new RuntimeException(                    "empty data passed into OutputSimulator.fixData");        }        //      A shot is an instant when one or more xrays are fired        double numberOfShots = data.length / (expectedSystem.availableData(1));        if (Math.rint(numberOfShots) != numberOfShots)        {            throw new RuntimeException(                    "malformated data passsed into fixoutput");        }        int numberOfPairs = expectedSystem.getNumberOfSDP();        boolean inside = true;        for (int shot = 0; shot < numberOfShots; shot++)        {            for (int sdp = 0; sdp < numberOfPairs; sdp++)            {                //TODO: replace this call with                // expectedSystem.getDetectorWidth(sdp);                int detectorWidth = (int) expectedSystem.getSDP(sdp)                        .getDetector().getPixelWidth();                //TODO: replace this call with                // expectedSystem.getDetectorHeight(sdp);                int detectorHeight = (int) expectedSystem.getSDP(sdp)                        .getDetector().getPixelHeight();                int offset = (shot * expectedSystem.availableData(1))                        + (sdp * expectedSystem.dataPerArray());                for (int i = 0; i < expectedSystem.dataPerArray(); i = i + 2)                {                    //                      outside the furthest bounds of detector array                    if (data[offset + i] > detectorWidth)                    {                        if((data[offset + i] - detectorWidth) > 10)                        {                            throw new RuntimeException("Data is too bad! cant fix it");                        }                        else                        {                            data[offset + i] = detectorWidth - 1;                        }                    }                    if (data[offset + i + 1] > detectorHeight)                    {                        if((data[offset + i+ 1] - detectorHeight) > 10)                        {                            throw new RuntimeException("Data is too bad! cant fix it");                        }                        else                        {                            data[offset + i + 1] = detectorHeight - 1;                        }                    }                    //outside smallest bounds of detector array                    if (data[offset + i] < 1)                    {                        if(data[offset + i]< -10)                        {                            throw new RuntimeException("Data is too bad! cant fix it");                        }                        else                        {                            data[offset + i] = 1;                        }                    }                    if (data[offset + i + 1] < 1)                    {                        if(data[offset + i + 1] < 0)                        {                            throw new RuntimeException("Data is too bad! cant fix it");                        }                        else                        {                            data[offset + i + 1] = 1;                        }                    }                }            }        }    }            //TODO: add throws upon too bad data    /*    protected double[] createFixedOutput(double[] data)    {        double[] newData = data;        if (!simulated)        {            throw new RuntimeException(                    "Fixing real data! Fixing data should only occur "                            + "when dealing with simulated data");        }        if (data == null)        {            throw new RuntimeException(                    "empty data passed into OutputSimulator.fixData");        }        System.out.println("fixing output for simulated data");        double numberOfShots = data.length / (expectedSystem.availableData(1));        if (Math.rint(numberOfShots) != numberOfShots)        {            throw new RuntimeException(                    "malformated data passsed into createFixedOutput");        }        int numberOfPairs = expectedSystem.getNumberOfSDP();        boolean inside = true;        for (int shot = 0; shot < numberOfShots; shot++)        {            for (int sdp = 0; sdp < numberOfPairs; sdp++)            {                //TODO: replace this call with                // expectedSystem.getDetectorWidth(sdp);                int detectorWidth = (int) expectedSystem.getSDP(sdp)                        .getDetector().getDetectorWidth();                //TODO: replace this call with                // expectedSystem.getDetectorHeight(sdp);                int detectorHeight = (int) expectedSystem.getSDP(sdp)                        .getDetector().getDetectorHeight();                int offset = (shot * expectedSystem.availableData(1))                        + (sdp * expectedSystem.dataPerArray());                for (int i = 0; i < expectedSystem.dataPerArray(); i = i + 2)                {                    //                      outside the furthest bounds of detector array                    if (data[offset + i] > detectorWidth)                    {                        newData[offset + i] = detectorWidth - 1;                    }                    if (data[offset + i + 1] > detectorHeight)                    {                        newData[offset + i + 1] = detectorHeight - 1;                    }                    //outside smallest boubds of detector array                    if (data[offset + i] < 1)                    {                        newData[offset + i] = 1;                    }                    if (data[offset + i + 1] < 1)                    {                        newData[offset + i + 1] = 1;                    }                }            }        }        return newData;    }    */        /**     *      * @param p1     * @param p2     * @param p3     * @param p4     * @return nearest intersection of 2 lines; the line from p1-p2 and the line     *         from p3-p4     */    protected Point3d nearestIntersect(Point3d p1, Point3d p2, Point3d p3,            Point3d p4)    {        double eps = Math.pow(10, -6); //1 micron min between        double[] p13 = new double[3];        double[] p43 = new double[3];        double[] p21 = new double[3];        double[] pa = new double[3];        double[] pb = new double[3];        p13[0] = p1.x - p3.x;        p13[1] = p1.y - p3.y;        p13[2] = p1.z - p3.z;        p43[0] = p4.x - p3.x;        p43[1] = p4.y - p3.y;        p43[2] = p4.z - p3.z;        p21[0] = p2.x - p1.x;        p21[1] = p2.y - p1.y;        p21[2] = p2.z - p1.z;        //System.out.println("boo");        if ((Math.abs(p43[0]) < eps) && (Math.abs(p43[1]) < eps)                && (Math.abs(p43[2]) < eps))        {            //            System.out.println(p4);            //            System.out.println(p3);            //            System.out.println(p43[0]);            //            System.out.println(p43[1]);            //            System.out.println(p43[2]);            throw new RuntimeException("bad points passed into guess generator");        }        else if ((Math.abs(p21[0]) < eps) && (Math.abs(p21[1]) < eps)                && (Math.abs(p21[2]) < eps))        {            throw new RuntimeException("bad points passed into guess generator");        }        else        {            double d1343 = p13[0] * p43[0] + p13[1] * p43[1] + p13[2] * p43[2];            double d4321 = p43[0] * p21[0] + p43[1] * p21[1] + p43[2] * p21[2];            double d1321 = p13[0] * p21[0] + p13[1] * p21[1] + p13[2] * p21[2];            double d4343 = p43[0] * p43[0] + p43[1] * p43[1] + p43[2] * p43[2];            double d2121 = p21[0] * p21[0] + p21[1] * p21[1] + p21[2] * p21[2];            double denom = d2121 * d4343 - d4321 * d4321;            if (Math.abs(denom) < eps)            {                throw new RuntimeException(                        "Bad points passed into guess generator");            }            double numer = d1343 * d4321 - d1321 * d4343;            double mua = numer / denom;            double mub = (d1343 + d4321 * mua) / d4343;            //System.out.println("foo");            pa[0] = p1.x + mua * p21[0];            pa[1] = p1.y + mua * p21[1];            pa[2] = p1.z + mua * p21[2];            pb[0] = p3.x + mub * p43[0];            pb[1] = p3.y + mub * p43[1];            pb[2] = p3.z + mub * p43[2];            double xMid = (pa[0] + pb[0]) / 2;            double yMid = (pa[1] + pb[1]) / 2;            double zMid = (pa[2] + pb[2]) / 2;            return new Point3d(xMid, yMid, zMid);        }    }        //Hope and pray that we dont overwrite too far... TODO:put bounds checking    // in here!    protected static void overwrite(double[] from, double[] into, int intoOffset)    {        int writePoint = intoOffset;        for (int fromPoint = 0; fromPoint < from.length; fromPoint++)        {            into[writePoint] = from[fromPoint];            writePoint++;        }    }    /**     *      * @return: new array whose contents are the elements of head appended to elements of tail     */    protected static double[] append(double[] head, double[] tail)    {        double[] newArray = new double[head.length+tail.length];        for (int i = 0; i<head.length; i++)        {            newArray[i] = head[i];        }        for (int i = 0; i<tail.length; i++)        {            newArray[i+head.length] = tail[i];        }        return newArray;    } }