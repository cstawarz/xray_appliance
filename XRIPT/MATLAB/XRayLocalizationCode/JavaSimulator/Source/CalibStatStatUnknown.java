package Simulator;import javax.vecmath.Point2d;import javax.vecmath.Point3d;/** * @author Daniel Oreper * Created on May 12, 2005 */public class CalibStatStatUnknown extends OutputGenerator{    private double maxPixelError; //initiallySet to impossible large maxPixelError        public CalibStatStatUnknown(XRAYSystem expectedSystem, double[] actualValues)    {        super(expectedSystem, actualValues);        if (actualValues.length != expectedSystem.availableData(1))        {            throw new RuntimeException("Malformatted actualValues passed into go constructor");        }	        maxPixelError = 1000;    }        /*     * Format of X must be of the form:     * [Translation1(s0),     * Translation2(s0),     * Translation3(s0),     * Translation1(d1),      * Translation2(d1),     * Translation3(d1),     * RotationNormal(d1),      * RotationPolar(d1),     * RotationAzimuthal(d1),     * Translation1(s1),     * Translation2(s1),     * Translation3(s1),     * Rotation(d0-d1),...      * Translation1(dn),     * Translation2(dn),     * Translation3(dn),     * Translation1(sn),     * Translation2(sn),      * Translation3(sn),      * RotationNormal(dn),     * RotationPolar(dn),     * RotationAzimuthal(dn),     * Rotation(d0-dn),     * Translation1(f0),     * Translation2(f0),     * Translation3(f0),...     * Translation1(fn),      * Translation2(fn),     * Translation3(fn)]     */    public double[] calcExpected(double[] X)    {        for (int sdp = 0; sdp < expectedSystem.getNumberOfSDP(); sdp++)        {            if (sdp == 0)            {                double dt1 = X[0];                double dt2 = X[1];                double dt3 = X[2];                expectedSystem.setDetectorTranslation(dt1,dt2,dt3,0);                double st1 = X[3];                double st2 = X[4];                double st3 = X[5];                expectedSystem.setSourceTranslation(st1, st2, st3, 0);            }            else             {                double dt1 = X[sdp * 10 - 4];                double dt2 = X[sdp * 10 - 3];                double dt3 = X[sdp * 10 - 2];                expectedSystem.setDetectorTranslation(dt1, dt2, dt3, sdp);                double dr1 = X[sdp * 10 - 1];                double dr2 = X[sdp * 10 - 0];                double dr3 = X[sdp * 10 + 1];                expectedSystem.setDetectorAngles(dr1, dr2, dr3, sdp);                double st1 = X[sdp * 10 + 2];                double st2 = X[sdp * 10 + 3];                double st3 = X[sdp * 10 + 4];                expectedSystem.setSourceTranslation(st1, st2, st3, sdp);                double rot = X[sdp * 10 + 5];                expectedSystem.rotateSDP(rot, sdp);            }        }        int constantOffset = 10 * expectedSystem.getNumberOfSDP() - 4;        for (int xIndex = constantOffset; xIndex < X.length; xIndex = xIndex + 3)        {            double t1 = X[xIndex];            double t2 = X[xIndex + 1];            double t3 = X[xIndex + 2];            int fiducialIndex = (xIndex - constantOffset) / 3;            try {                                        expectedSystem                    .setLightFiducialPosition(t1, t2, t3, fiducialIndex);            }            catch(RuntimeException rt)            {                System.out.println(expectedSystem);                System.out.println(t1);                System.out.println(t2);                System.out.println(t3);                System.out.println(fiducialIndex);                throw new RuntimeException("caught and thrown fid exception");            }        }        this.expectedOutput = expectedSystem.getIdealCentersOfProjection();        return (double[]) this.expectedOutput.clone();    }        /**     * @requires: We have a valid upper bound on maxPixelError! very important     * @return actualValues - expectedOutput, multiplying by 10     * if the expected output is out of bounds.     * Also. scale each foutput[i] by 1 + ((x / maxPixelError) ^6) to      * punish for differences that are beyond the maxPixelError     */    public double[] calcF(double[] X)    {        if (!hasActualValues())        {            throw new RuntimeException("No actualValues with which to calcF");        }        if (!outputInBounds(actualValues))        {            throw new RuntimeException(                    "Trying to calculate F with data that is out of bounds.");        }        calcExpected(X); //sets this.expectedOutput        if (!outputInBounds(this.expectedOutput))        {            for (int i = 0; i < this.expectedOutput.length; i++)            {                this.fOutput[i] = 10 * (actualValues[i] - this.expectedOutput[i]);            }        }        else        {            for (int i = 0; i < this.expectedOutput.length; i++)            {                this.fOutput[i] = actualValues[i] - this.expectedOutput[i];                //TODO: write this to incorporate maxpixelerror                //this.fOutput[i] = this.fOutput[i]*(1 + Math.pow(this.fOutput[i] *.75, 6));            }        }        return (double[]) this.fOutput.clone();    }            public int getRequiredInputSize()    {          return (10 * expectedSystem.getNumberOfSDP() - 4 +                    3 * expectedSystem.getNumberOfFiducials());      }        public double[] generateGuess()    {        if (!hasActualValues())        {            throw new RuntimeException("No data with which to generate guess");        }        //checking to make sure our actualValues are inBounds        if (!outputInBounds(actualValues))        {            //if bad data was created using simulation, simply fix the data.            if (this.isSimulatedData())            {                this.fixOutput(actualValues);            }            //if bad data is real data, throw exception            else            {                throw new RuntimeException(                        "Trying to generate a guess with data that is outside of reasonable bounds,"                                + "Check means by which data is inputted to outputSimulator");            }        }        //System.out.println("generating guess");        //expectedSystem.reCenter();        //double[] xGuess = new double[24];               //System.out.println("guessing");       int numSDP = expectedSystem.getNumberOfSDP();       if (numSDP < 2)         {                throw new RuntimeException(                        "not enough data to generate init guess");            }            int dataPerArray = actualValues.length / numSDP;            // System.out.println(dataPerArray);            SourceDetectorPair sdp1 = expectedSystem.getSDP(0);            DetectorArray det1 = sdp1.getDetector();            Source src1 = sdp1.getSource();            SourceDetectorPair sdp2 = expectedSystem.getSDP(1);            DetectorArray det2 = sdp2.getDetector();            Source src2 = sdp2.getSource();            Point3d s1 = src1.getCenter();            Point3d d1 = new Point3d();            Point3d s2 = src2.getCenter();            Point3d d2 = new Point3d();            Point2d temp1 = new Point2d();            Point2d temp2 = new Point2d();            for (int i = 0; i < dataPerArray; i = i + 2)            {                double xIndex1 = actualValues[i];                double yIndex1 = actualValues[i + 1];                temp1.set(xIndex1, yIndex1);                d1.set(det1.detectorToPhysical(temp1));                double xIndex2 = actualValues[i + dataPerArray];                double yIndex2 = actualValues[i + 1 + dataPerArray];                temp2.set(xIndex2, yIndex2);                d2.set(det2.detectorToPhysical(temp2));                //System.out.println("guessing");                Point3d fidGuess = nearestIntersect(s1, d1, s2, d2); //finds                int fiducialIndex = i / 2;                Point3d presentLocation = expectedSystem                        .getFiducialLocation(fiducialIndex);                expectedSystem.setLightFiducialPosition(fidGuess.x                        - presentLocation.x, fidGuess.y - presentLocation.y,                        fidGuess.z - presentLocation.z, fiducialIndex); //careful!!//                expectedSystem.reCenter();            }            double[] xGuess = getSampleInput();            return xGuess;    }        public int getRequiredOutputSize()    {        return expectedSystem.availableData(1);    }        public double[] getSampleInput()    {        return new double[this.getRequiredInputSize()];    }        public boolean outputInBounds(double[] data)    {        return super.outputInBounds(data) && data.length == getRequiredOutputSize();    }            /**     * @effects: set the maximum assumed amount of imaging error in actualvalues     * Used in the punishment function.     * @param d     */    public void setMaxPixelError(double pixelError)    {        	this.maxPixelError = pixelError;    }}