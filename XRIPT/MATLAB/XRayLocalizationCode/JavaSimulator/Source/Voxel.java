/** * @OVERVIEW: *  *  * Voxel represent a cube volume in space, centered about some center with edge length voxelSize. * A voxel has some attenuation, represnting how well it stops xrays. Any xRay attenuating object * which we want to discretize can be represented by a collection of voxels * * Inheritance information: * This class extends transformable object. * Each instance is a non self-moving version of a transformable Object. */	/** * @specfield attenuation: int xray attenuating coefficient * @specfield voxelSize: float edge length of the cube voxel *//* * Voxel.java * Created on Sep 5, 2004 * By Daniel Oreper  */package Simulator;import javax.vecmath.Point3d;//import com.sun.rsasign.t;public class Voxel extends TransformableObject{    private int attenuation; //the attenuation coeeficient of the voxel    private double voxelSize; //edge length of a cubic voxel           /**     * @param attenuation     * @param initCenter     * @param voxelSize     * @effects: creates new Voxel s.t. center is initCenter,     * this.attenuation = attenuation,  this.voxelSize = voxelSize     * Voxel is an instance of a lightweight TransformableObject     */    public Voxel(Point3d initCenter,			int attenuation,            double voxelSize)    {    		//This object has been made a lightweight object as we do not want     		//the voxels making up an object    		//to move indpently of their heavy fiducial parent.     		//Furthermore, non moving objects use less memory- no child list, and no trajectory to hold.    		//See description of TransformableObject for clarification    	    		super(initCenter, false, false); //false argument for lightwieght,    		//false argument for moving rotaiton center, not that it matters        this.attenuation = attenuation;        this.voxelSize = voxelSize;    }        public Voxel()    {        super(new Point3d(), false, true);        this.attenuation = 0;        this.voxelSize = 0;    }      //TODO: implement if needed    /**     * @return: boolean indicating whether or not r intersects the volume contained by the voxel     *///    public boolean intersects(Ray r)//    {//        return true;//    }        //TODO: implement if needed    /**     * @return: the length of the intersection between r and the voxel.     * If the ray does not intersect, return 0     *///    public float getIntersectDistance(Ray r)//    {//        return 1;//    }    	    /**     * @return String representation of a voxel     * @effects: super.toString() gets most recent location information => call to super.recalculate().      * see Transformable object for state changes associated with recalculate.      */    public String toString()    {    		String s = "";    		s = s + "Voxel: " + "\n";    		s = s + super.toString();    		s = s + "Atenuation is: " + getAttenuation() + "\n";    		s = s + "Voxel size is: " + getVoxelSize() + "\n";    	    		return s;    }    	/**	 * @return: Returns the attenuation.	 */	public int getAttenuation()	{		return attenuation;	}	    				/**	 * @return Returns the voxelSize.	 */	public double getVoxelSize() 	{		return voxelSize;	}		/**	 * @return new instance v s.t. this.equals(v)	 */	public Object clone()	{	     Voxel v = new Voxel();	     v.set(this);	     return v;	}		/**	 * @effects	 * 	 * @param v	 * this.attenuation = v.attenuation	 * 	 */	public void set(Voxel v)	{				super.set(v);		//subtype checking		if(v instanceof Voxel)		{			this.attenuation = v.attenuation;			this.voxelSize = v.voxelSize;		}			else throw new RuntimeException("Trying to set transformableObjects" +				"that are not equivalent to one another:"+ this.toString() +				"\n" + v.toString());					}	//	public boolean equals(Voxel v)//	{//		//	}//		}