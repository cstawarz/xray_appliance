/* * Created on Jun 18, 2005 * */package Simulator;import javax.vecmath.Point2d;import javax.vecmath.Point3d;/** * @author Daniel Oreper * Created on Jun 18, 2005 */public class CalibMovingStatKnown extends OutputGenerator{    private double[] expectedRotations;    //private double maxPixelError; //initiallySet to impossible large maxPixelError    //private ArrayList fiducialCollections;    int firstOffset;    int secondOffset;    int thirdOffset;    int fourthOffset;    int fifthOffset;        public CalibMovingStatKnown(XRAYSystem expectedSystem, double[] expectedRotations,double[] actualValues)    {        super(expectedSystem, actualValues);                        firstOffset = 6; //6 detector and source translations needed to determine coord frame                 //for every sdp beyond the second, there are         //3 soiurce Translation and 3 detector translation- 3+3 = 6         secondOffset =              firstOffset + (expectedSystem.getNumberOfSDP() - 2) * 6;                  //for every sdp, there are 3 detector angles that are unknown         thirdOffset = secondOffset + 3 * expectedSystem.getNumberOfSDP();                  //for every fiducialColection, there are 6 unknowns - 3 trans, 3 rot          fourthOffset = thirdOffset + 6;                  //for every rotary stage (1), there are 3 unknown position variables,          //and 2 varibles to determine the axis of the rotary stage         fifthOffset = fourthOffset + 5;                 if (actualValues.length != expectedSystem.availableData(expectedRotations.length+1))        {            System.out.println(this.getRequiredOutputSize());            System.out.println(actualValues.length);            throw new RuntimeException("Malformatted actualValues passed into go constructor");        }//        if (expectedRotations.length<1)//        {//            throw new RuntimeException("Using a rotation simulatro for case with no rotation- " +//            		"change to CalibStatStatUnknown");//        }//        if(fiducalCollections.length<1)//        {//            throw new RuntimeException("Malformatted fiducialcollections passed in")//        }        //        maxPixelError = 1000;        this.expectedRotations = expectedRotations;    }        /*     * Format of X must be of the form:     * [Translation1(s0),     * Translation2(s0),     * Translation3(s0),     * Translation1(d1),      * Translation2(d1),     * Translation3(d1),     * RotationNormal(d1),      * RotationPolar(d1),     * RotationAzimuthal(d1),     * Translation1(s1),     * Translation2(s1),     * Translation3(s1),     * Rotation(d0-d1),...      * Translation1(dn),     * Translation2(dn),     * Translation3(dn),     * Translation1(sn),     * Translation2(sn),      * Translation3(sn),      * RotationNormal(dn),     * RotationPolar(dn),     * RotationAzimuthal(dn),     * Rotation(d0-dn),     * Translation1(f0),     * Translation2(f0),     * Translation3(f0),...     * Translation1(fn),      * Translation2(fn),     * Translation3(fn)],      *  rotation Point OffsetX     * rotation Point OffsetY     * rotation Point OffsetZ     *     * rotation axis x      * rotation axis y     * rotation axis z     * rotation 1,     * fct1     * fct2     * fct3     * fcr1     * fcr2     * fcr3     * ...     * rotation n      */    public double[] calcExpected(double[] X)    {//      source and detector translations of the first 2        //detector pairs        double s0_t1 = X[0];        expectedSystem.setSourceTranslation(s0_t1, 0, 0, 0);        double s1_t1 = X[1];        double s1_t2 = X[2];        expectedSystem.setSourceTranslation(s1_t1, s1_t2, 0, 1);        double d1_t1 = X[3];        double d1_t2 = X[4];        double d1_t3 = X[5];        expectedSystem.setDetectorTranslation(d1_t1, d1_t2, d1_t3, 1);                //source and detector translation of detector pairs        //beyond the second sdp        for (int sdp = 2; sdp < expectedSystem.getNumberOfSDP(); sdp++)        {            double si_t1 = X[firstOffset + 6 * sdp];            double si_t2 = X[firstOffset + 6 * sdp + 1];            double si_t3 = X[firstOffset + 6 * sdp + 2];            expectedSystem.setSourceTranslation(si_t1, si_t2, si_t3, sdp);                        double di_t1 = X[firstOffset + 6 * sdp + 3];            double di_t2 = X[firstOffset + 6 * sdp + 4];            double di_t3 = X[firstOffset + 6 * sdp + 5];            expectedSystem.setDetectorTranslation(di_t1, di_t2, di_t3, sdp);        }                //rotations for all detectors        for (int sdp = 0; sdp<expectedSystem.getNumberOfSDP(); sdp++)        {            double di_r1 = X[secondOffset + 3 * sdp];            double di_r2 = X[secondOffset + 3 * sdp + 1];            double di_r3 = X[secondOffset + 3 * sdp + 2];            expectedSystem.setDetectorAngles(di_r1, di_r2, di_r3, sdp);        }                double fct1 = X[thirdOffset];        double fct2 = X[thirdOffset + 1];        double fct3 = X[thirdOffset + 2];        double fcr1 = X[thirdOffset + 3];        double fcr2 = X[thirdOffset + 4];        double fcr3 = X[thirdOffset + 5];              //translations and rotations of the fiducialCollection        expectedSystem.getFids().fct1(fct1);        expectedSystem.getFids().fct2(fct2);        expectedSystem.getFids().fct3(fct3);        expectedSystem.getFids().fcr1(fcr1);        expectedSystem.getFids().fcr2(fcr2);        expectedSystem.getFids().fcr3(fcr3);                //translateing the rotary stage, and setting its axis        double staget1 = X[fourthOffset];        double staget2 = X[fourthOffset + 1];        double staget3 = X[fourthOffset + 2];        //TODO: fix this call to avoid getFids()        expectedSystem.getFids().t1(staget1);        expectedSystem.getFids().t2(staget2);        expectedSystem.getFids().t3(staget3);                //axis        double polar = X[fourthOffset + 3];        double azimuthal = X[fourthOffset + 4];        expectedSystem.getFids().setIdealRotationAxis(polar, azimuthal);                //harvesting data from the system        try{            expectedSystem.rotateFiducials(0);            //offset is 0 as this is the first set of projections            expectedSystem.            getIdealCentersOfProjection(expectedOutput, 0);        }        catch (RuntimeException re)        {            OutputGenerator.printArray(X);            System.out.println(expectedSystem);            throw(re);        }        for(int rotationIndex = 0;         rotationIndex < expectedRotations.length;        rotationIndex++)        {            double rot = expectedRotations[rotationIndex] + X[fifthOffset + rotationIndex];            expectedSystem.rotateFiducials(rot);            //aaccumulating projections from more rotations and placeing them into expectedOutput            expectedSystem.getIdealCentersOfProjection            (expectedOutput, (rotationIndex+1)*expectedSystem.availableData((1)));        }        return (double[]) this.expectedOutput.clone();    }        /**     * @requires: We have a valid upper bound on maxPixelError! very important     * @return actualValues - expectedOutput, multiplying by 10     * if the expected output is out of bounds.     * Also. scale each foutput[i] by 1 + ((x / maxPixelError) ^6) to      * punish for differences that are beyond the maxPixelError     */    public double[] calcF(double[] X)    {        if (!hasActualValues())        {            throw new RuntimeException("No actualValues with which to calcF");        }//        if (!outputInBounds(actualValues))//        {//            throw new RuntimeException(//                    "Trying to calculate F with data that is out of bounds.");//        }        calcExpected(X); //sets this.expectedOutput//        if (!outputInBounds(this.expectedOutput))//        {//            for (int i = 0; i < this.expectedOutput.length; i++)//            {//                this.fOutput[i] = 10 * (actualValues[i] - this.expectedOutput[i]);//            }//        }        return this.fOutput;    }            public int getRequiredInputSize()    {        return fifthOffset + expectedRotations.length;    }         /**     * @requires: expectedSystem is unperturbed     */    public double[] generateGuess()    {                double[] xGuess = getSampleInput();        //offset at which we need to change the sample input to hold        //fiducial position guesses        int sampleInputOffset = 10 * expectedSystem.getNumberOfSDP() - 1;        if (!hasActualValues())        {            throw new RuntimeException("No data with which to generate guess");        }        //checking to make sure our actualValues are inBounds        if (!outputInBounds(actualValues))        {            //if bad data was created using simulation, simply fix the data.            if (this.isSimulatedData())            {                this.fixOutput(actualValues);            }            //if bad data is real data, throw exception            else            {                throw new RuntimeException(                        "Trying to generate a guess with data that is outside of reasonable bounds,"                                + "Check means by which data is inputted to outputSimulator");            }        }        //System.out.println("generating guess");//        expectedSystem.reCenter();        //double[] xGuess = new double[24];               //System.out.println("guessing");       int numSDP = expectedSystem.getNumberOfSDP();       if (numSDP < 2)         {                throw new RuntimeException(                        "not enough data to generate init guess");            }            int dataPerArray = expectedSystem.availableData(1) / numSDP;            // System.out.println(dataPerArray);            SourceDetectorPair sdp1 = expectedSystem.getSDP(0);            DetectorArray det1 = sdp1.getDetector();            Source src1 = sdp1.getSource();            SourceDetectorPair sdp2 = expectedSystem.getSDP(1);            DetectorArray det2 = sdp2.getDetector();            Source src2 = sdp2.getSource();            Point3d s1 = src1.getCenter();            Point3d d1 = new Point3d();            Point3d s2 = src2.getCenter();            Point3d d2 = new Point3d();            Point2d temp1 = new Point2d();            Point2d temp2 = new Point2d();            for (int i = 0; i < dataPerArray; i = i + 2)            {                double xIndex1 = actualValues[i];                double yIndex1 = actualValues[i + 1];                temp1.set(xIndex1, yIndex1);                d1.set(det1.detectorToPhysical(temp1));                double xIndex2 = actualValues[i + dataPerArray];                double yIndex2 = actualValues[i + 1 + dataPerArray];                temp2.set(xIndex2, yIndex2);                d2.set(det2.detectorToPhysical(temp2));                //System.out.println("guessing");                Point3d fidGuess = nearestIntersect(s1, d1, s2, d2); //finds                int fiducialIndex = i / 2;                Point3d presentLocation = expectedSystem                        .getFiducialLocation(fiducialIndex);                double t1 = fidGuess.x - presentLocation.x;                double t2 = fidGuess.y - presentLocation.y;                double t3 = fidGuess.z - presentLocation.z;//                expectedSystem.setFiducialTranslation(//                        t1,t2,t3,fiducialIndex);                xGuess[sampleInputOffset + 3 * fiducialIndex]     = t1;                xGuess[sampleInputOffset + 3 * fiducialIndex + 1] = t2;                xGuess[sampleInputOffset + 3 * fiducialIndex + 2] = t3;                //expectedSystem.reCenter();            }            return xGuess;    }        public int getRequiredOutputSize()    {        return expectedSystem.availableData(1)*(1+expectedRotations.length);    }        public double[] getSampleInput()    {           double[] xGuess =             new double[getRequiredInputSize()];                return xGuess;    }    public boolean outputInBounds(double[] data)    {        return super.outputInBounds(data) && data.length == getRequiredOutputSize();    }        //    /**//     * @effects: set the maximum assumed amount of imaging error in actualvalues//     * Used in the punishment function.//     * @param d//     *///    public void setMaxPixelError(double pixelError)//    {//        	this.maxPixelError = pixelError;//    }}