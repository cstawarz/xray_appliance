//TODO: create static constructor that will initialize parents!!/*  * Fiducial.java * Created on Sep 11, 2004 * By Daniel Oreper  */package Simulator;import javax.vecmath.Point3d;import javax.vecmath.Tuple3d;import java.util.*;public class HeavyFiducial extends Fiducial{    private double radius; // radius of the fiducial    private double noiseVariance; //maximum percenteage value of fiducial attenuation that noisy voxels can take    private double fiducialAttenuation; // constant expected attenuation of the fiducial    private double voxelVolume;    //volume of one of the cubic voxels contained in a fiducial     private double voxelSize; //edge of a cubic voxel        /**     * @OVERVIEW:     * A fiducial is a small metal ball that has some ideal attenuation. This attenuation may not be      * constant throughout the fiducial.       * We model a fiducial through the composition of many Voxels into a sphere shaped object.     *      *      * Inheritance information:     * Fiducial extends TransformableObject, and is self-moving     */        /**     * @specfield: center: Point3d center of the fiducial     * @specfield: radius: int radius of spherical fiducial     * @specfield: voxels: int number of voxels from the center     * to the outside of the fiducial. This higher the number, the smaller a given voxel,     * The better the approximation of fiducial projection becomes     * @specfield: attenuation: double ideal attenuation of any voxel in the fiducial      * @specfield: noiseVariance: int maximum variance from the ideal attenuation of the fiducial in a given voxel     */        /**     * @param center: center of a spehrical fiducial     * @param radius: radius of a spherical fiducial     * @param voxels : Number of discretizations of the fiducial in the radial direction, not counting the center voxel-     *  this is how we assign how finely we want to approximate a fiducails projection     * @param fiducialAttenuation : constant attenuation of the fiducial body     * @param variance : max attenuation of surrounding "dirty" voxels     *      * @effects: creates     */        private HeavyFiducial(Point3d initCenter,    						   double radius, 							               				   int numVoxels,            				   int fiducialAttenuation,            				   int noiseVariance)    {    		super(initCenter);        this.fiducialAttenuation = fiducialAttenuation;        this.radius = radius;        this.noiseVariance = noiseVariance;        this.voxelVolume = voxelSize * voxelSize * voxelSize;        if(numVoxels!=0)        {            this.voxelSize = (radius/(numVoxels-.5));         }        //building voxels to make up a sphere rigid Body        Point3d voxelCenter;        Voxel voxel;        for (int i=0; i<2*numVoxels-1; i++)        {            for (int j=0; j<2*numVoxels-1; j++)            {                for (int k=0; k<2*numVoxels-1; k++)                {                    voxelCenter = new Point3d((i+.5)*voxelSize + initCenter.x - radius,                            					(j+.5)*voxelSize + initCenter.y - radius,                            					(k+.5)*voxelSize + initCenter.z - radius);                                        double distanceToCenter = voxelCenter.distance(initCenter);                                        if(distanceToCenter>radius)                    {                        //int randomAttenuation = (int) (Math.random()*0);//noiseVariance); //rounding                        //voxel = new Voxel(voxelCenter, randomAttenuation, voxelSize);                         //this.addChild(voxel);                    }                    else                    {                        voxel = new Voxel(voxelCenter,                        		(int)(fiducialAttenuation + (2 * Math.random()-1)*noiseVariance*.01),                        		voxelSize);                        this.addChild(voxel);                    }                                       //voxel.setParent(this);                }            }        }    }        //returns fiducial with voxelsize 1, with num voxels to outside//    public static Fiducial BuildDefault(Point3d fiducialMeasuredCenter,//												int numVoxels) 							   								//    {//    		Fiducial f = new Fiducial(fiducialMeasuredCenter, //        					  numVoxels - .5,//							numVoxels,//							1,//							0);//    //    		f.giveChildrenParents();//    		return f;//    }//        public static HeavyFiducial BuildFiducial(Point3d initCenter,			   double radius, 							   			   int numVoxels,			   int fiducialAttenuation,			   int noiseVariance)    {    		HeavyFiducial f = new HeavyFiducial(initCenter, radius, numVoxels, fiducialAttenuation, noiseVariance);    		f.giveChildrenParents();    		return f;    }            public static HeavyFiducial BuildDefault(Point3d initCenter,    									  	int numVoxels,										int pctNoise)  	{    		HeavyFiducial f = new HeavyFiducial(initCenter, 200, numVoxels, 100, 100+pctNoise);    		f.giveChildrenParents();    		return f;	}        public static HeavyFiducial BuildDefault(Point3d initCenter)    {        HeavyFiducial f = new HeavyFiducial(                initCenter,                200, 							   			   0,			   1,			   0);        return f;    }        public static HeavyFiducial BuildDefault()    {        HeavyFiducial f = new HeavyFiducial(new Point3d(),0,0,1,0);        return f;    }           /**	 * @return Returns the attenuation.	 */	public double getFiducialAttenuation()	{		return fiducialAttenuation;	}		public Iterator getVoxels()	{		return getChildren();	}	    /**     * @return Returns the noiseVariance.     */    public double getNoiseVariance()    {        return noiseVariance;    }        /**     * @return Returns the radius.     */    public double getRadius()    {        return radius;    }            /**     * @return Returns the voxelSize.     */    public double getVoxelSize()    {        return voxelSize;    }    /**     * @return Returns the voxelVolume.     */    public double getVoxelVolume()    {        return voxelVolume;    }        public String toString()    {    		Iterator iter = getChildren();    	        String s = "";        s = s + "Fiducial: " +"\n";        s = s + super.toString();        s = s + "Radius is: " + getRadius() +"\n";        return s;    }        public String tobjectProperties()    {        String s = "";        return s;                }        public void setLocation(Tuple3d location)    {        this.setInitPosition(location);    }        public void setXDisplacement(double d)    {    		this.setInitTranslation1(d);    }        public void setYDisplacement(double d)    {    		this.setInitTranslation2(d);    }        public void setZDisplacement(double d)    {    		this.setInitTranslation3(d);    }    public void printAttenuatingVoxels()    {    		System.out.println("Attenuating voxels are: ");        Iterator iter = getVoxels();        while (iter.hasNext())        {            Voxel v = (Voxel)(iter.next());            if (v.getAttenuation()==fiducialAttenuation)            {                System.out.println(v.getCenter());            }        }        System.out.println();    }        public static void main(String[] args)    {        HeavyFiducial f = HeavyFiducial.BuildFiducial(new Point3d(0,0,0),290,2,3,0);        f.printAttenuatingVoxels();    }        /**     * Only Works for point fiducials     */    public Object clone()    {        HeavyFiducial f = HeavyFiducial.BuildDefault();        f.set(this);        return (Object)f;    }        /** only works for Point Fiducials     *      * @param f     */    public void set(HeavyFiducial f)    {        if (this.hasChildren()||voxelSize!=0||voxelVolume!=0)        {            throw new RuntimeException("caling set on a non point fiducial");        }        super.set(f);        this.fiducialAttenuation = f.fiducialAttenuation;        this.noiseVariance = f.noiseVariance;        this.radius = f.radius;        this.voxelSize = f.voxelSize;        this.voxelVolume = f.voxelVolume;    }    /* (non-Javadoc)     * @see Simulator.TransformableObject#specialRecenter()     */    public void specialRecenter()    {        // TODO Auto-generated method stub            }        }