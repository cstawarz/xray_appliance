/* * XRAYSystem.java * Created on Sep 29, 2004 * By Daniel Oreper *///TODO: draw picture/**  @OVERVIEW:  This class represents an xRay system.   It is basically a container class for a collection of Source Detector Pairs, and a lone fiducial Collection.    This class is the primary non-gui interface to xRay simulation  It abstracts the user away from calls to the set and get methods of fiducials,  fiducial collections, and source and detector array set and get methods  *//** * @specfield sourceDetectorPairs: collection of Source detector pairs in the system * @specfield fids: FiducialCollection of the fiducials that the xray system can project */package Simulator;import java.util.*;import javax.vecmath.Point2d;import javax.vecmath.Point3d;import javax.vecmath.Vector3d;public class XRAYSystem extends TransformableObject{	private ArrayList sourceDetectorPairs;    private RotaryStage fids;         /**      @effects: Builds new xRay system with empty sourcedetectorPairs, and with an empty fids      @modifies: this     */    private XRAYSystem(Point3d center)    {        super(center);    		    }        /**     *      * @return an XRAYSystem with no fiducials in fids, and no sdp's     */    public static XRAYSystem BuildDefault()	{    		XRAYSystem xray = new XRAYSystem(new Point3d());    		xray.fids = RotaryStage.BuildDefault(new Point3d());    		xray.sourceDetectorPairs = new ArrayList();    		xray.addChild(xray.fids);    		xray.giveChildrenParents();    		return xray;	}        /**     * @modifies: this     * @effects:     *  creates a new sdp s.t. sdp.source.center = new Point3d(-sourceDistance,0,0);     * and s.t. sdp.detectorArray.center = new Point3d(arrayDistance,0,0), and appends this sdp to the end     * of sourceDetectorPairs     */    public void addDefaultSourceDetectorPair(double sourceDistance, double arrayDistance)     {        Point3d sourceCenter =  new Point3d(-sourceDistance, 0, 0);        Point3d detectorCenter = new Point3d(arrayDistance, 0, 0);        Point3d sdpCenter = new Point3d(0, 0, 0);        SourceDetectorPair sdp = SourceDetectorPair.BuildDefault(               sourceCenter,                detectorCenter,                 sdpCenter);    		     		sourceDetectorPairs.add(sdp);    		this.addChild(sdp);    }    /**     * @modifies: this     * @effects:     *  creates a new sdp similar to addDefaultSDP without rotation argument,      *  except rotated by rotation clockwise about the z axis, appends to sourceDetectorPairs     */        public void addDefaultSourceDetectorPair(double sourceDistance, double arrayDistance, double rotation)    {    		SourceDetectorPair sdp = SourceDetectorPair.BuildDefault(sourceDistance, arrayDistance, rotation);    		sourceDetectorPairs.add(sdp);    		this.addChild(sdp);    }       /**    * As above, except the detector array is parameterized to have non default number of rows,    * columns,     * detectorWidth,    * detectorHeight.    * @param sourceDistance    * @param arrayDistance    * @param rotation    * @param rows    * @param columns    * @param detectorWidth    * @param detectorHeight    */    public void addDefaultSourceDetectorPair(double sourceDistance,     			double arrayDistance,    			double rotation,    			int rows,             int columns,              double detectorWidth,             double detectorHeight)    {    		SourceDetectorPair sdp =     			SourceDetectorPair.BuildDefault(sourceDistance,     										   arrayDistance,    										   rotation,    										   rows,    										   columns,    										   detectorWidth,    										   detectorHeight);    		sourceDetectorPairs.add(sdp);    		this.addChild(sdp);    }        /**     * @modifies: this     * @effects: appends sdp to the end     * of sourceDetectorPairs     */    public void addSourceDetectorPair(SourceDetectorPair sdp)    {        sourceDetectorPairs.add(sdp);        this.addChild(sdp);    }            /**     * @modifies: this     * @effects: adds f to fids     */    public void addFiducial(Fiducial f)    {    		fids.addFiducial(f);    }      /**     * @modifies: this     * @effects: creates a lightFiducial      * s.t. lf.attenuation = 1, lf.radius = 0, and lf.center = (xCenter, yCenter, zCenter)      * Adds lf to Fids     * @param xCenter     * @param yCenter     * @param zCenter     */    public void addDefaultLightFiducial(            double xCenter,             double yCenter,             double zCenter)        {        LightFiducial f =             LightFiducial.BuildDefault(new Point3d(xCenter, yCenter, zCenter));        fids.addFiducial(f);    }           /**     * @effects: removes all fiducials from this     *     */    public void emptyFids()    {        fids.empty();    }        /**     *      * @return the fiducial collection translation along x axis     */    public double getFCT1()    {    		return fids.getFCT1();    }        /**     *      * @return the fiducial collection translation along y axis     */    public double getFCT2()    {    		return fids.getFCT2();    }        /**     *      * @return fiducial collection translation along z axis     */    public double getFCT3()    {    		return fids.getFCT3();    }        /**     *      * @return fiducial collection rotation along the first axis of the fiducial collection-     *      */    public double getFCR1()    {    		return fids.getFCR1();    }        public double getFCR2()    {    		return fids.getFCR2();    }        public double getFCR3()    {    		return fids.getFCR3();    }         /**     *      * @set fiducial collection rotation along the first axis of the fiducial collection-     *      */    public void setFCR1(double d)    {    		fids.fcr1(d);    }        /**     *      * @set fiducial collection rotation along the second axis of the fiducial collection-     *      */    public void setFCR2(double d)    {    		fids.fcr2(d);    }        /**     *      * @set fiducial collection rotation along the third axis of the fiducial collection-     *      */    public void setFCR3(double d)    {    		fids.fcr3(d);    }        public void setFCT1(double d)    {    		fids.fct1(d);    }        public void setFCT2(double d)    {    		fids.fct2(d);    }        public void setFCT3(double d)    {    		fids.fct3(d);    }            public Point2d getIdealCenterOfProjection(int fiducialIndex, int sdpIndex)    {        Ray r = new Ray(new Point3d(), new Vector3d());   		Point3d fidCenter = this.getFiducialLocation(fiducialIndex);   		Source source = ((SourceDetectorPair)sourceDetectorPairs.get(sdpIndex)).getSource();   		DetectorArray array = ((SourceDetectorPair)sourceDetectorPairs.get(sdpIndex)).getDetector();   		source.getRay(fidCenter, r);   		Point2d projectedCenter = array.getDetectorIntersectionContinuous(r);   		return projectedCenter;    }        public double[] getIdealCentersOfProjection()    {        double[] projections = new double [availableData(1)];//matrix where we store the projected center points of each fiducial 		        //looping over all source detector Pairs        int counter = 0;        Iterator sdps = sourceDetectorPairs.iterator();        Ray r = new Ray(new Point3d(), new Vector3d());        while (sdps.hasNext())        {            SourceDetectorPair sdp = (SourceDetectorPair)sdps.next();            Source source = sdp.getSource(); //the source of particular sdp            DetectorArray array = sdp.getDetector(); //detectorArray of particular sd     	               //looping over all fiducials            Iterator fiducials = fids.getFiducials();				   		while (fiducials.hasNext()) 	        	{		        		TransformableObject to = (TransformableObject) fiducials.next();	       		Point3d fidCenter = to.getCenter();	       		source.getRay(fidCenter, r);	       		Point2d projectedCenter = array.getDetectorIntersectionContinuous2(r);	    			//if we have projected off of the array we have a problem.	       		if (projectedCenter == null)	    			{	    			    throw new RuntimeException("fiducial projected to a point off of the detector array!" +"\n"+	    			            "center could not be collected");	    			}	       		else	       		{	       		    projections[counter] = projectedCenter.x;	       		    counter++;	       		    projections[counter] = projectedCenter.y;	       		    counter++;	       		}   		 	}  		        }        return projections;    }        //THis is a fast method of getting centers of projection that is meant to be used    //in reconstruction.     //mutates the projections vector starting at the offset point    protected void getIdealCentersOfProjection(double[] projections, int offset)    {        Iterator sdps = sourceDetectorPairs.iterator();        while (sdps.hasNext())        {            //fiducials iterator            Iterator fiducials = fids.getFiducials();            //source detector pair we are projecting            SourceDetectorPair sdp = (SourceDetectorPair)sdps.next();            sdp.getIdealCentersOfProjection(fiducials, projections, offset);            //moving the array offset for the next sdp projection            offset = offset + getNumberOfFiducials()*2;        }    }           public double[][] project2(int discretization, int sdpIndex)    {            	if  (sourceDetectorPairs.size() - 1 < sdpIndex ||sdpIndex<0)		{	    		 	System.out.println("Invalid sdpIndex: ");    			System.out.println(sdpIndex);			throw new RuntimeException("projectFiducials called with non existent sdp");				}    		    		    		else    		{	    			SourceDetectorPair sdp = (SourceDetectorPair) sourceDetectorPairs.get(sdpIndex);        		Source source = sdp.getSource();        		DetectorArray array = sdp.getDetector();        					array.wipeClean();			Iterator fiducials = fids.getFiducials();						while (fiducials.hasNext()) 			{					Fiducial fid = (Fiducial) fiducials.next();				array.project2(fid, source, discretization);			}			return array.getExposures();		}	}            // Use this method to see the effect of a non point source.    /** mutates source radius in the middle of calculation     *      * @param sdpIndex     * @param discretization     * @param radius     * @return     */    public double[][] project3(int sdpIndex, int discretization, double sourceRadius)    {    	if  (sourceDetectorPairs.size() - 1 < sdpIndex ||sdpIndex<0)		{				throw new RuntimeException("pojectFiducials called with non existent sdp");		}    		    		    		else    		{	    			SourceDetectorPair sdp = (SourceDetectorPair) sourceDetectorPairs.get(sdpIndex);        		Source source = sdp.getSource();        		double oldRadius = source.getRadius();        		source.setRadius(sourceRadius);        		DetectorArray array = sdp.getDetector();        					Iterator fiducials = fids.getFiducials();						while (fiducials.hasNext()) 			{					Fiducial fid = (Fiducial) fiducials.next();				array.project3(fid, source, discretization);			}			source.setRadius(oldRadius);			return array.getExposures();		}	}        //returns the projection onto sdpindxth detector array, traating projections of fiducials    //as squares centered at ideal centers of proejction with radius pixelRadius    public double[][] project4(int sdpIndex, int pixelRadius)    {    	double[] expectedOutput = this.getIdealCentersOfProjection();    	double[][] output = new double[this.getSDP(sdpIndex).getDetector().getRows()]    	                               [this.getSDP(sdpIndex).getDetector().getColumns()];    	double[] relevantPortion = new double[this.getNumberOfFiducials() * 2];    	int offset =  sdpIndex * 2 * this.getNumberOfFiducials();    	for (int i = 0; i < relevantPortion.length; i++)    	{    		relevantPortion[i] = expectedOutput[offset + i];    	}    	for (int i = 0; i < relevantPortion.length; i = i + 2)    	{    		for (int j = -1 * pixelRadius; j < pixelRadius + 1; j++)    		{    			for (int k = -1 * pixelRadius; k < pixelRadius + 1; k++)    			{    				int column = (int) Math.floor(relevantPortion[i]) + j;    				int row = (int) Math.floor(relevantPortion[i + 1]) + k;    				if ((row < this.getSDP(sdpIndex).getDetector().getRows()) && (row > -1)    						&& (column < this.getSDP(sdpIndex).getDetector().getColumns()) && (column > -1))    				{    					output[row][column] = 1;    				}    			}    		}    	}    	return output;    }        public int dataPerArray()    {        	return (this.getNumberOfFiducials()*2);    }        public int availableData(int rotations)    {    		return (rotations) * this.sourceDetectorPairs.size()*fids.getNumberOfFiducials()*2;    }        /**     *      * @return number of sdp's     */    public int getNumberOfSDP()    {    		return sourceDetectorPairs.size();    }        /**     *      * @return number of fiducials in fids     */    public int getNumberOfFiducials()    {    		return fids.getNumberOfFiducials();    }    /**     * @requires: fiducialIndexth fiducial exists     * @return: location of the fiducialIndexth fiducial     */    public Point3d getFiducialLocation(int fiducialIndex)    {        return fids.getFiducialLocation(fiducialIndex);    }           /**     * @requires: an electrode and at least 3 fiducials exist     * @return: coordinates of funknownth fiducial in a reference frame s.t.     * f1th fiducial is origin, basis1 is normalized vector from f1th fiducial to      * f2th fiducial, basis2 is normalized part of vector from f1th fiducial      * to f3th fiducial that is perpendicular to basis1, and basis3 is      * cross product of basis1 and basis2     *       */    public Point3d getFiducialLocationRelativeToFiducialFrame(int target,    		int f1, int f2, int f3)    {    	BasisCollection bc;    	try{    		    	     bc =     		BasisCollection.BuildOrthoUnitBasisCollection(getFiducialLocation(f1),    			getFiducialLocation(f2),    			getFiducialLocation(f3));        }    catch(RuntimeException e)    {    		    		System.out.println("cannot form a frame using fiducials " + f1 + "," + f2 + "," + f3);    		System.out.println(getFiducialLocation(f1));    		System.out.println(getFiducialLocation(f2));    		System.out.println(getFiducialLocation(f3));    		throw e;    }    	return bc.toNew(getFiducialLocation(target));    }    public static Point3d getFiducialLocationRelativeToFiducialFrame    (Point3d targetCenter,     		Point3d f1Center,    		Point3d f2Center,    		Point3d f3Center)    {    	BasisCollection bc;		try {			bc = BasisCollection.BuildOrthoUnitBasisCollection(f1Center,					f2Center, f3Center);		} catch (RuntimeException e) {			System.out.println("cannot form a frame using fiducials "					+ f1Center + "," + f2Center + "," + f3Center);			System.out.println(f1Center);			System.out.println(f2Center);			System.out.println(f3Center);			throw e;		}		return bc.toNew(targetCenter);        }        /**     *      * @param sdpIndex     * @return  the sdpIndexth detector's polar angle, azimuthal angle, normal Angle in a point3d object     */    public Point3d getDetectorAngles(int sdpIndex)    {        DetectorArray det = ((SourceDetectorPair)(this.sourceDetectorPairs.get(sdpIndex))).getDetector();        double polar = det.getPolarAngle();        double azimuthal = det.getAzimuthalAngle();        double normal = det.getNormalAngle();        return new Point3d(polar, azimuthal, normal);    }        /**     *      * @param sdpIndex     * @return  the sdpIndexth detector's azimuthal angle     */    public double getDetectorAzimuthalAngle(int sdpIndex)    {        DetectorArray det = ((SourceDetectorPair)(this.sourceDetectorPairs.get(sdpIndex))).getDetector();        return det.getAzimuthalAngle();    }        /**     *      * @param sdpIndex     * @return  the sdpIndexth detector's polar angle     */    public double getDetectorPolarAngle(int sdpIndex)    {        DetectorArray det = ((SourceDetectorPair)(this.sourceDetectorPairs.get(sdpIndex))).getDetector();        return det.getPolarAngle();    }        /**     *      * @param sdpIndex     * @return  the sdpIndexth detector's normal angle     */    public double getDetectorNormalAngle(int sdpIndex)    {        DetectorArray det = ((SourceDetectorPair)(this.sourceDetectorPairs.get(sdpIndex))).getDetector();        return det.getNormalAngle();    }        public Vector3d getDetectorNormal(int detectorIndex)    {    		return getSDP(detectorIndex).getDetector().getNormal();    }        /**     *      * @param sdpIndex     * @return  present center locatoin of the the sdpIndeth detecor     */    public Point3d getDetectorLocation(int sdpIndex)    {        DetectorArray det = ((SourceDetectorPair)(this.sourceDetectorPairs.get(sdpIndex))).getDetector();        return det.getCenter();    }    //    public double getDetectorTranslationNormal                /**     *      * @param sdpIndex     * @return  present center locatoin of the the sdpIndeth source     */    public Point3d getSourceLocation(int sdpIndex)    {        Source src = ((SourceDetectorPair)(this.sourceDetectorPairs.get(sdpIndex))).getSource();        return src.getCenter();    }           /**     * @requires: fiducialIndxth fiducail is lightwieght     * @param xCoordinate     * @param yCoordinate     * @param zCoordinate     * @param fiducialIndex     */    public void setLightFiducialPosition(double xCoordinate, double yCoordinate, double zCoordinate, int fiducialIndex)    {        if (fiducialIndex>fids.getNumberOfFiducials()-1||fiducialIndex<0)		{			throw new RuntimeException("setting fiducial parameter of a fiducial that doesnt yet exist" + fiducialIndex);		}		else 		{			fids.setLightFiducialPosition(xCoordinate, yCoordinate, zCoordinate, fiducialIndex);		}    }        public void perturbLightFiducialPosition(double deltaX, double deltaY, double deltaZ, int fiducialIndex)    {        if (fiducialIndex>fids.getNumberOfFiducials()-1||fiducialIndex<0)		{			throw new RuntimeException("setting fiducial parameter of a fiducial that doesnt yet exist" + fiducialIndex);		}		else 		{			fids.perturbLightFiducialPosition(deltaX, deltaY, deltaZ, fiducialIndex);		}    }        public void setLightFiducialRadius(double radius, int fiducialIndex)    {    	 if (fiducialIndex>fids.getNumberOfFiducials()-1||fiducialIndex<0)    	 { 			throw new RuntimeException("setting fiducialradius of a fiducial that doesnt yet exist" + fiducialIndex); 		} 		else  		{ 			fids.setLightFiducialRadius(radius, fiducialIndex); 		}    }            public void rotateSDP(double angle, int sdpIndex)    {        SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);        sdp.rotateAboutNormal(angle);    }        /**     *      * @return angle of fids rotation     */    public double getRotaryStagePrimaryRotationAngle()    {    		return fids.getRotaryRotationAngle();    }        public void setRotaryStagePrimaryAxis(double x, double y, double z)    {    		fids.setNormalAxis(new Vector3d(x, y, z));    }            public void setSourceTranslation(double towardDetector, double horizontal, double vertical, int sdpIndex)    {    		SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);    		Source src = sdp.getSource();    		src.setTranslationToDetectorArray(towardDetector);    		src.setVerticalTranslation(vertical);    		src.setHorizontalTranslation(horizontal);    }        public void setSourceTranslationTowardDetector(double translation, int sdpIndex)    {        SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);        Source src = sdp.getSource();        src.setTranslationToDetectorArray(translation);    }        public void setSourceTranslationVertical(double translation, int sdpIndex)    {        SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);        Source src = sdp.getSource();        src.setVerticalTranslation(translation);    }        public void setSourceTranslationHorizontal(double translation, int sdpIndex)    {        SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);        Source src = sdp.getSource();        src.setHorizontalTranslation(translation);    }               public void setDetectorAngles(double detectorPolar, double detectorAzimuthal, double detectorNormal, int sdpIndex)    {    		SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);    		sdp.getDetector().setRotationAboutAzimuthal(detectorAzimuthal);    		sdp.getDetector().setRotationAboutPolar(detectorPolar);    		sdp.getDetector().setRotationAboutNormal(detectorNormal);    }	        public void setDetectorPolarAngle(double detectorPolar, int sdpIndex)    {        SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);        sdp.getDetector().setRotationAboutPolar(detectorPolar);    }        public void setDetectorAzimuthalAngle(double detectorAzimuthal, int sdpIndex)    {        SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);        sdp.getDetector().setRotationAboutAzimuthal(detectorAzimuthal);    }        public void setDetectorNormalAngle(double detectorNormal, int sdpIndex)    {        SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);        sdp.getDetector().setRotationAboutAzimuthal(detectorNormal);    }         public void setDetectorTranslation(double normalTranslation, double horizontalTranslation, double verticalTranslation, int sdpIndex)    {    		SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);    		sdp.getDetector().setTranslationHorizontal(horizontalTranslation);    		sdp.getDetector().setTranslationVertical(verticalTranslation);    		sdp.getDetector().setTranslationFromSource(normalTranslation);    }        public void setSDPTranslation(double t1, double t2, double t3, int sdpIndex)    {        SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);        sdp.setSDPTranslation(t1,t2,t3);    }        public Point3d getSDPRotation(int sdpIndex)    {    		SourceDetectorPair sdp = getSDP(sdpIndex);    		return new Point3d(sdp.getRotation1(),     				   sdp.getRotation2(),     				   sdp.getRotation3());    }            public Point3d getSDPTranslation(int sdpIndex)    {    		SourceDetectorPair sdp = getSDP(sdpIndex);    		return new Point3d(sdp.getTranslation1(),    						  sdp.getTranslation2(),    						  sdp.getTranslation3());    }    	    public void setSDPRotation(double r1, double r2, double r3, int sdpIndex)    {        SourceDetectorPair sdp = (SourceDetectorPair)sourceDetectorPairs.get(sdpIndex);        sdp.setSDPRotation(r1,r2,r3);    }                    /**     * @return: String representation of XRAY System     */    public String toString()    {    		        String s = super.toString();        s = s + "XRAY SYSTEM: " + "\n";        s = s + "SDPs: " + "\n";        Iterator sdps = sourceDetectorPairs.iterator();        while (sdps.hasNext())        {            SourceDetectorPair pair = (SourceDetectorPair)sdps.next();            s = s + pair.toString();        }                s = s + fids.toString() +"\n";                return s;    }            public SourceDetectorPair getSDP(int index)    {        return (SourceDetectorPair)this.sourceDetectorPairs.get(index);    }        //TODO implement needed methods into system. -r1, r2, r3, t1, t2, t3    public RotaryStage getFids()    {        return this.fids;    }        /**     *      * @return location of 0th fiducial     */    public Point3d getElectrodeLocation()    {        //TODO: change this        return fids.getFiducialLocation(0);    }        /**     * @requires: an electrode and at least 3 fiducials exist     * @return: coordinates of 0th fiducial in a reference frame s.t.     * 1th fiducial is origin, basis1 is normalized vector from 1th fiducial to      * 2th fiducial, basis2 is normalized part of vector from 1th fiducial      * to 3th fiducial that is perpendicular to basis1, and basis3 is      * cross product of basis1 and basis2     *       */    public Point3d getElectrodeLocationRelativeToFiducialFrame()    {    	BasisCollection bc =     		BasisCollection.BuildOrthoUnitBasisCollection(getFiducialLocation(1),    				getFiducialLocation(2),    				getFiducialLocation(3));    	return bc.toNew(getElectrodeLocation());    }    //    /**//     * @effects: fiducialIndxth fiducial is shifted in its own reference frame by//     * xTranslation, yTranslation, zTranslation. This reference frame may not be the normal x,y,z//     * frame- if a rotation of 90 degrees were to occur around the z axis, //     * an xTranslation of 1 in the fiducials frame would correspond to a yTranslation of 1 in the XraySystem.//     * This is clearest to undestand if one imagines fiducials to be translated first, and then rotated//     * //     *///    public void setFiducialTranslation(double xTranslation, double yTranslation, double zTranslation, int fiducialIndex)//    {//    		if (fiducialIndex>fids.getNumberOfFiducials()-1||fiducialIndex<0)//    		{//    			throw new RuntimeException("setting fiducial parameter of a fiducial that doesnt yet exist" + fiducialIndex);//    		}//    		else //    		{//    			fids.setFiducialTranslation(xTranslation, yTranslation, zTranslation, fiducialIndex);//    		}//    }      protected void rotateFiducials(double angle)  {  		fids.rotateAboutRotationAxis(angle);  }}        