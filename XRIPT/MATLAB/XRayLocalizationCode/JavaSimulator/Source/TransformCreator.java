//TODO: write all the .equals methods//TODO: optimization for this class//TODO: decide on whether tranlation vecotrs are mvoing too/*  * TransformCreator.java * Created on Sep 5, 2004 * By Daniel Oreper  */package Simulator;import javax.vecmath.*;import javax.media.j3d.*;/** * @OVERVIEW: class implements a transform creator by describing a transform in terms of its  * transaltion, rotation about 3 axes, axes, and bases. Primary method for use is getTransform(),  * which modifies a local variable and returns a Transform. * A TransformCreator can be lightweight, in which case operations  * dealing with the rotation offset,  * axes of rotation, change of basis, change of axes do nothing.  * Only Transforms that translate by (translate1, translate2, translate3) * are performed *  *///**/**     * @specfield: translate1: double distance this transformCreator wil     *             transform an elements postion along basis1     *      * @specfield: translate2: double distance this transformCreator wil     *             transform an elements postion along basis2     *      * @specfield: translate3: double distance this transformCreator wil     *             transform an elements postion along basis3     *      * @specfield: basis1: basis vector of translation     *      * @specfield: basis2: basis vector of translation     *      * @specfield: basis3: basis vector of translation     *      * @specfield: axis1: a vector of rotation along which transofrm created by     *             creator till rotate     *      * @specfield: axis2: a vector of rotation along which transofrm created by     *             creator till rotate     *      * @specfield: axis3: a vector of rotation along which transofrm created by     *             creator till rotate     *      * @specfield angle1: double amount of rotation along axis1     *      * @specfield angle2: double amount of rotation along axis2     *      * @specfield angle3: double amount of rotation along axis3     *      * @specfield rotationCenter: Point3d that all axes of rotation go through     *     * @specfield centered: boolean that is true if the center of rotaiton moves with translation     */public class TransformCreator{//	translation amounts    private double translate1;    private double translate2;    private double translate3;    //The vector along which the transformation matrix created will translate a    // distance t1    private Vector3d basis1;    //  The vector along which the transformation matrix created will translate a    // distance t2    private Vector3d basis2;    //  The vector along which the transformation matrix created will translate a    // distance t3    private Vector3d basis3;        //axis 1 of rotation    private Vector3d axis1;    //axis2 of rotation    private Vector3d axis2;    //axis3 of rotation    private Vector3d axis3;    //angle around axis1    private double angle1;    //angle around axis2    private double angle2;    //angle around axis3    private double angle3;    private boolean movingRotationCenter;        private Point3d rotationOffset;        //Variables which should be local to getTransform, but are kept globally to save allocation time within that method    //see method for understanding variables        private Transform3D rotationTransform1 = new Transform3D();    private Transform3D rotationTransform2 = new Transform3D();    private Transform3D rotationTransform3 = new Transform3D();    private Transform3D netRotationTransform = new Transform3D();    private Transform3D netTransform = new Transform3D();    //private Transform3D output =            private Vector3d translationOffset = new Vector3d();    private Transform3D translateTransform = new Transform3D();    private Vector3d offsetVec = new Vector3d();    private Transform3D offsetTransform = new Transform3D();    private Transform3D unOffsetTransform = new Transform3D();            private AxisAngle4d aa1 = new AxisAngle4d();    private AxisAngle4d aa2 = new AxisAngle4d();    private AxisAngle4d aa3 = new AxisAngle4d();        private Point3d shiftedRotationOffset = new Point3d();    ////    //these objects are built in the constructor with 0 values rather than locally in a method, to save time//    private AxisAngle4d aa1; //used to store the complex axis-angle data//    private AxisAngle4d aa2; //used to store the complex axis-angle data//    private Vector3d translationOffset; //used to store the combined offsets in every basis direction//    private Vector3d rotationOffset; //stores the offset neede to rotate about the correct point- not nec origin//    private Matrix3d rotationMatrix1; //stores the matrix that rotates about axis 1, by angle1(t)//    private Matrix3d rotationMatrix2; //stores the matrix that rotates about axis 2, by angle2(t)   //    private Matrix4d matrixTransform;//    private Transform3D transform;        public TransformCreator()    {    	    this.movingRotationCenter = true;        this.angle1 = 0;        this.angle2 = 0;        this.angle3 = 0;                //z axis is default axis 1        this.axis1 = new Vector3d(0, 0, 1);        //x axis is default axis 2        this.axis2 = new Vector3d(1, 0, 0);        //y axis is default axis 3        this.axis3 = new Vector3d(0, 1, 0);                this.basis1 = new Vector3d(1, 0, 0);        this.basis2 = new Vector3d(0, 1, 0);        this.basis3 = new Vector3d(0, 0, 1);        this.rotationOffset = new Point3d();    }        public TransformCreator(boolean movingRotationCenter)    {    	    this.movingRotationCenter = movingRotationCenter;        this.angle1 = 0;        this.angle2 = 0;        this.angle3 = 0;                //z axis is default axis 1        this.axis1 = new Vector3d(0, 0, 1);        //x axis is default axis 2        this.axis2 = new Vector3d(1, 0, 0);        //y axis is default axis 3        this.axis3 = new Vector3d(0, 1, 0);                this.basis1 = new Vector3d(1, 0, 0);        this.basis2 = new Vector3d(0, 1, 0);        this.basis3 = new Vector3d(0, 0, 1);        this.rotationOffset = new Point3d(0, 0, 0);    }    public void set(TransformCreator tother)    {    	    this.movingRotationCenter = tother.movingRotationCenter;        this.angle1 = tother.angle1;        this.angle2 = tother.angle2;        this.angle3 = tother.angle3;        this.axis1.set(tother.axis1);        this.axis2.set(tother.axis2);        this.axis3.set(tother.axis3);        this.basis1.set(tother.basis1);        this.basis2.set(tother.basis2);        this.basis3.set(tother.basis3);        this.rotationOffset.set(tother.rotationOffset);        this.translate1 = tother.translate1;        this.translate2 = tother.translate2;        this.translate3 = tother.translate3;    }    /**     * @ return: TransformCreator tcnew s.t. tcnew.equals(this)     */    public Object clone()    {        TransformCreator tnew = new TransformCreator();        tnew.set(this);        return tnew;    }    /**     * @param time      * @return the Transform associated with shifting and rotating.     *      * Shifting by:     * (translate1(time), translate2(time), translate3(time)).     *      * Rotating:     *      */        //TODO: document this method    public Transform3D getTransform()    {    		//TODO: speedup this method, keep locals in memory, pass in transforms    		double offset1 = translate1; //the amount by which we translate in the direction of basis1 at time=time        double offset2 = translate2; //the amount by which we translate in the direction of basis2 at time=time        double offset3 = translate3; //the amount by which we translate in the direction of basis3 at time=time        double rotate1 = Math.toRadians(angle1); //the amount by which we rotate around axis 1 at time=time;        double rotate2 = Math.toRadians(angle2); //the amount by which we rotate around axis 2 at time=time;        double rotate3 = Math.toRadians(angle3);                  //CREATING ROTATION PART:        // axes of rotation        aa1.set(axis1, rotate1);        aa2.set(axis2, rotate2);        aa3.set(axis3, rotate3);                //netRotationTransform is the collection of all rotations,         //rotating first about axis3, then axis2, then axis1        //rotation are with respect to origin        //if there is an angle 1 rotation reassing rotationtransform1        if(rotate1!=0)        {        		rotationTransform1.set(aa1);        		netRotationTransform.set(rotationTransform1);        }                //if there is an angle 2 rotation reassign rotationtransform2        if(rotate2!=0)        {             		rotationTransform2.set(aa2);        		//setting net transform        		if (rotate1 == 0)        		{        			netRotationTransform.set(rotationTransform2);        		}        		//otherwise        		else         		{        			netRotationTransform.mul(rotationTransform2);        		}        }                //if there is an angle 3 rotation reassign rotation transform3        if (rotate3!=0)        {        		rotationTransform3.set(aa3);        		//setting netTransform        		if ((rotate1 == 0)&&(rotate2 == 0))        		{        			netRotationTransform.set(rotationTransform3);        		}        		else        		{        			netRotationTransform.mul(rotationTransform3);        		}        }                        if((rotate1==0)&&(rotate2==0)&&(rotate3==0))        {        		netRotationTransform.setIdentity();        }	                //CREATING TRANSLATION PART:                //combining the offset in each basis direction into one vector offset.        //translateTransform holds translation matrix        translationOffset.set(basis1);        translationOffset.scale(offset1);        translationOffset.scaleAdd(offset2, basis2, translationOffset);        translationOffset.scaleAdd(offset3, basis3, translationOffset);        translateTransform.set(translationOffset);                 //important point!        //making a new rotation offset so that the tranlation moves the rotation point wiht the rest of body        translateTransform.transform(rotationOffset, shiftedRotationOffset);                //the offset matrix to prepare for rotation- moves body to be centered about origin, so that rotation is correct        offsetVec.set(shiftedRotationOffset);        offsetVec.scale(-1);        offsetTransform.set(offsetVec); //moving the rotation offset in effect to the origin                        //unoffseting for after rotation        offsetVec.scale(-1);        unOffsetTransform.set(offsetVec);        if(this.movingRotationCenter)        {        		//translating first, then rotating        		netTransform.set(unOffsetTransform);         		netTransform.mul(netRotationTransform); //netTransform = netTransform*netRotationTransform         		netTransform.mul(offsetTransform); //netTransform = netTransform*offsetTransform         		netTransform.mul(translateTransform); //netTransform = netTransform*translateTransform         }        else        {        		//rotating first, and then translating        		netTransform.set(translateTransform);        		netTransform.mul(netRotationTransform);         }	        	//TODO: pass in output rather than allocating?        return netTransform;    }        /**     * @modifies this     */    public void TransformSelfBy(Transform3D transform)    {        transform.transform(this.rotationOffset);        transform.transform(axis1);        transform.transform(axis2);        transform.transform(axis3);        transform.transform(basis1);        transform.transform(basis2);        transform.transform(basis3);    }        public void setToZero()    {        this.angle1 = 0;        this.angle2 = 0;        this.angle3 = 0;        this.translate1 = 0;        this.translate2 = 0;        this.translate3 = 0;    }            public String toString()    {        String s="";        s = s + "Transform: " + "\n";        s = s + "Basis1 Translation: " + getTranslate1() + "\n";        s = s + "Basis2 Translation: " + getTranslate2() + "\n";        s = s + "Basis3 Translation: " + getTranslate3() + "\n";        s = s + "Basis1: " + getBasis1() +"\n";        s = s + "Basis2: " + getBasis2() +"\n";        s = s + "Basis3: " + getBasis3() +"\n";        s = s + "Axis1 Rotation: " + getAngle1() + "\n";        s = s + "Axis2 Rotation: " + getAngle2() + "\n";        s = s + "Axis3 Rotation: " + getAngle3() + "\n";        s = s + "Axis1: " + getAxis1() + "\n";        s = s + "Axis2: " + getAxis2() + "\n";        s = s + "Axis3: " + getAxis3() + "\n";        s = s + "Rotation Offset Point: " + getRotationOffset() + "\n";        s = s + "GetTransform at time = 0: " + "\n";        s = s + getTransform() + "\n";         return s;          }        /**     * @return Returns the angle1.     */    public double getAngle1()    {        return angle1;    }        /**     * @param angle1 The angle1 to set.     */    public void setAngle1(double angle1)    {        this.angle1 = angle1;    }           /**     * @return Returns the angle2.     */    public double getAngle2()    {        return angle2;    }    /**     * @param angle2 The angle2 to set.     */        public void setAngle2(double angle2)    {        this.angle2 = angle2;    }        /**     * @return Returns the angle3.     */    public double getAngle3()    {        return angle3;    }    /**     * @param angle3 The angle3 to set.     */    public void setAngle3(double angle3)    {        this.angle3 = angle3;    }       /**     * @return Returns the axis3.     */    public Vector3d getAxis3()    {        return (Vector3d)axis3.clone();    }    /**     * @param axis3 The axis3 to set.     */    public void setAxis3(Vector3d axis3)    {        this.axis3.set(axis3);    }        public void setAxis3(double x, double y, double z)    {        axis3.set(x, y, z);    }        /**     * @return Returns the axis1.     */    public Vector3d getAxis1()    {        return (Vector3d)axis1.clone();    }    /**     * @param axis1 The axis1 to set.     */    public void setAxis1(Vector3d axis1)    {        this.axis1.set(axis1);    }        public void setAxis1(Transform3D transform)    {        transform.transform(axis1);    }        public void setAxis1(double x, double y, double z)    {        axis1.set(x, y, z);    }    /**     * @return Returns the axis2.     */    public Vector3d getAxis2()    {        return (Vector3d)axis2.clone();    }    /**     * @param axis2 The axis2 to set.     */    public void setAxis2(Vector3d axis2)    {        this.axis2.set(axis2);    }        public void setAxis2(Transform3D transform)    {        transform.transform(axis2);    }        public void setAxis2(double x, double y, double z)    {        axis2.set(x, y, z);    }        /**     * @return Returns the rotationOffset.     */    public Point3d getRotationOffset()    {        return (Point3d)rotationOffset.clone();    }    /**     * @param rotationOffset The rotationOffset to set.     */    public void setRotationOffset(Point3d rotationOffset)    {        this.rotationOffset.set(rotationOffset);    }        public void setRotationOffset(Transform3D transform)    {        transform.transform(rotationOffset);    }    /**     * @return Returns the translate1.     */    public double getTranslate1()    {        return translate1;    }    /**     * @param translate1 The translate1 to set.     */    public void setTranslate1(double translate1)    {        this.translate1 = translate1;    }            /**     * @return Returns the translate2.     */    public double getTranslate2()    {        return translate2;    }    /**     * @param translate2 The translate2 to set.     */    public void setTranslate2(double translate2)    {        this.translate2 = translate2;    }            /**     * @return Returns the translate3.     */    public double getTranslate3()    {        return translate3;    }    /**     * @param translate3 The translate3 to set.     */    public void setTranslate3(double translate3)    {        this.translate3 = translate3;    }        /**     * @return Returns the basis1.     */    public Vector3d getBasis1()    {        return (Vector3d)basis1.clone();    }    /**     * @return Returns the basis2.     */    public Vector3d getBasis2()    {        return (Vector3d)basis2.clone();    }    /**     * @return Returns the basis3.     */    public Vector3d getBasis3()    {        return (Vector3d)basis3.clone();    }         /**     * @param basis1 The basis1 to set.     */    public void setBasis1(Vector3d basis1)    {        this.basis1.set(basis1);    }        public void setBasis1(Transform3D transform)    {        transform.transform(basis1);    }        /**     * @param basis2 The basis2 to set.     */    public void setBasis2(Vector3d basis2)    {        this.basis2.set(basis2);    }        public void setBasis2(Transform3D transform)    {           transform.transform(basis2);     }        /**     * @param basis3 The basis3 to set.     */    public void setBasis3(Vector3d basis3)    {        this.basis3.set(basis3);    }        public void setBasis3(Transform3D transform)    {        transform.transform(basis3);    }        public static void main(String[] args)    {    	    }    }