/* * Created on Oct 14, 2004 */package Simulator;import javax.media.j3d.Transform3D;import javax.vecmath.Point3d;import javax.vecmath.Tuple3d;import javax.vecmath.Vector3d;import java.util.*;/** * @author Daniel Oreper */public abstract class TransformableObject{    /**     * OVERVIEW: see TranformableObject.doc     */        private TransformCreator initTrajectory; //TO's own trajectory without parental motion    private TransformCreator trajectory; //TO's trajectory with parental motion    private Point3d initCenter; //TO's own center in absence of any motion- intial center point    private Point3d center;//TO's cneter in presence of own and parnetal motion    private BasisCollection initOrientation; //Orientation of TO in the absence the motion of any enclosing transformable object, and in the absence of its own motion.    private BasisCollection orientation;// orientation including the effect of self motion and ancestral motion.        private TransformableObject parent;//immediately enclosing TO (can be null, or single TO)    private ArrayList children; //TOÕs that this TO encloses.        private boolean dirty;//actual values (trajectory, center, orientation) are only calculated on demand. They are not cached. Dirty boolean indicates whether actual values have been recalculated.      private boolean heavy;//: boolean indicating whether we have a complex TO.     private boolean movingRotationCenter; //Boolean determining whether or not the objects center of rotation moves with the center of  the object, or whether the center of rotation is always the origin of the coordinate frame.        //CONSTRUCTORS        /**     * 	@effects creates a new TransformableObject s.t.     *       *  this.initTrajectory = 0 (if heavy, otherise null)     *  this.trajectory = 0 (if heavy, otherwise null)     *  this.initCenter.equals(initCenter)     *  this.center.equals(initCenter)     *  this.initOrientation = null;     *  this.orientation = null;      *       *  this.parent = null;     *  this.children = empty list if heavy, null if not heavy this.center = initCenter;     *       *  this.dirty = true;     *  this.heavy = heavy;      *  this.movingRotationCenter = movingRotationCenter     */    protected TransformableObject(Point3d initCenter, boolean heavy, boolean movingRotationCenter)    {    		this.initTrajectory = null;    		this.trajectory = null;    		//cloning rather than setting equal to avoid dangerous side effects        this.initCenter = (Point3d) initCenter.clone();         this.center = (Point3d) initCenter.clone();    		//no orientation initially- this can be added later    		this.initOrientation = null;        this.orientation = null;                //no children initially- these can be added later        this.children = null;        //no parents initially- these can be added later        this.parent = null;                //A heavy object has its own trajectory, as well as children.        if (heavy)        {            //zero displacement transform creators        	   //if movingRotationCenter, the rotation center of trajectory moves with the translation of the trajectory.        	   //otherwise, rotation center stays the same as it is created (most likely at origin)            this.initTrajectory = new TransformCreator(movingRotationCenter);            initTrajectory.setRotationOffset(initCenter);            this.trajectory = new TransformCreator(movingRotationCenter);            trajectory.setRotationOffset(initCenter);            //allocating a childlist            this.children = new ArrayList();        }        //initializing the object to be "dirty"        this.makeDirty();                this.movingRotationCenter = movingRotationCenter;        this.heavy = heavy;    }        /**     *  Same as first most general constructor, but only creates heavy objects     *  with moving rotation centers.     *       * 	@effects creates a new TransformableObject s.t.     *       *  this.initTrajectory = 0 (if heavy, otherise null)     *  this.trajectory = 0 (if heavy, otherwise null)     *  this.initCenter.equals(initCenter)     *  this.center.equals(initCenter)     *  this.initOrientation = null;     *  this.orientation = null;      *       *  this.parent = null;     *  this.children = empty list if heavy, null if not heavy this.center = initCenter;     *       *  this.dirty = true;     *  this.heavy = true;      *  this.movingRotationCenter = true;     */    protected TransformableObject(Point3d initCenter)    {    	    this.initTrajectory = new TransformCreator(); //default transformcreator is for a moving rotation center        initTrajectory.setRotationOffset(initCenter);         this.trajectory = new TransformCreator(); //default transformcreator is for a moving rotation center        trajectory.setRotationOffset(initCenter);        this.initCenter = (Point3d)initCenter.clone();        this.center = (Point3d) initCenter.clone();        this.orientation = null;        this.initOrientation = null;                //parent can be set later          this.parent = null;        this.children = new ArrayList();               this.movingRotationCenter = true;        this.heavy = true;        this.makeDirty();    }            //GET METHODS    /**     * @return clone of trajectory     * @effects: recalculate effects     */    //Trajectory get Methods    public TransformCreator getTrajectory()    {        recalculate();        return (TransformCreator) trajectory.clone();    }        /**     * @return clone of init trajectory     * @effects: recalculate effects     */    protected TransformCreator getInitTrajectory()    {        recalculate();        return (TransformCreator) initTrajectory.clone();    }        /**     *      * @return objects own clockwise perturbation about its actual axis1 and center of rotation     */    public double getRotation1()	{    		recalculate();	    return initTrajectory.getAngle1();	}        /**     *      * @return objects own clockwise rotation perturbation about its actual axis2 and center of rotation     * @effects: recalculate effects     */	public double getRotation2()	{		recalculate();	    return initTrajectory.getAngle2();	}		 /**     * @effects: recalculate effects     * @return objects own clockwise rotation perturbation about its actual axis3 and center of rotation     */	public double getRotation3()	{		recalculate();	    return initTrajectory.getAngle3();	}    	/**	 * @effects: recalculate effects	 * @return objects own translation perturbation along its actual first basis vector	 */	public double getTranslation1()	{		recalculate();	    return initTrajectory.getTranslate1();	}		/**	 * @return objects own translation perturbation along its actual second basis vector	 * @effects: recalculate effects	 */    public double getTranslation2()    {        recalculate();        return initTrajectory.getTranslate2();    }        /**	 * @return objects own translation perturbation along its actual third basis vector	 * @effects: recalculate effects	 */    public double getTranslation3()    {        recalculate();        return initTrajectory.getTranslate3();    }	    /**     *      * @return objects first actual basis of translation, including the effect of parental motion     */    public Vector3d getBasis1()    {        recalculate();        return trajectory.getBasis1();    }        /**     *      * @return objects second actual basis of translation, including the effect of parental motion     */    public Vector3d getBasis2()    {        recalculate();        return trajectory.getBasis2();    }        /**     *      * @return objects third basis of translation, including the effect of parental motion     */    public Vector3d getBasis3()    {        recalculate();        return trajectory.getBasis3();    }               public Vector3d getInitBasis1()    {        recalculate();        return initTrajectory.getBasis1();    }       	/**     *      * @return objects second init basis of translation, excluding the effect of parental motion     */    public Vector3d getInitBasis2()    {        recalculate();        return initTrajectory.getBasis2();    }        /**     *      * @return objects third init basis of translation, excluding the effect of parental motion     */    public Vector3d getInitBasis3()    {        recalculate();        return initTrajectory.getBasis3();    }            /**	 * @return objects actual rotation axis, taking into account parental motion	 * @effects: recalculate effects	 */	public Vector3d getAxis1()	{	    recalculate();	    return trajectory.getAxis1();	}			  /**	 * @return objects first init rotation axis, in the absence of parental motion	 * @effects: recalculate effects	 */	public Vector3d getInitAxis1()	{		recalculate();	    return initTrajectory.getAxis1();	}		/**	 * @effects: recalculate effects	 * @return objects second init rotation axis, taking into account parental motion	 */	public Vector3d getAxis2()    {        recalculate();        return trajectory.getAxis2();    }	/**	 * @effects: recalculate effects	 * @return objects second init rotation axis, in the absence of parental motion	 */    public Vector3d getInitAxis2()    {        recalculate();        return initTrajectory.getAxis2();    }        /**     * @effects: recalculate effects     * @return objects actual third rotation axis, taking into account parental motion      */    public Vector3d getAxis3()    {        recalculate();        return trajectory.getAxis3();    }    /**     * @effects: recalculate effects     * @return objects init third rotation axis, in the absence of parental motion     */    public Vector3d getInitAxis3()    {        recalculate();        return initTrajectory.getAxis3();    }	        //Center get Methods        /**     * @return clone of this.initCenter     */    public Point3d getInitCenter()    {        return (Point3d) initCenter.clone();    }    /**     * @return Returns clone of the center.     * @effects: recalculate effects     */    public Point3d getCenter()    {        recalculate();        return (Point3d) (center.clone());    }    /**     * @effects: newCenter.equals(center)     * recalculate effects     * @param newCenter     */    public void getCenter(Tuple3d newCenter)    {        recalculate();        newCenter.set(center);    }            //Orientation get Methods    /**     * @return true if orientation!=null     */    private boolean hasOrientation()    {        return (orientation != null) & (initOrientation != null);    }        /**     * @requires: hasOrientation     * @return clone of orientation     * @effects: recalculate effects     */    public BasisCollection getOrientation()    {        if (!hasOrientation())        {            throw new RuntimeException            ("getting orientaion of soemthing with no orientaion");        }        else        {            recalculate();            return (BasisCollection)orientation.clone();        }    }        /**     * @effects: orientation.equals(this.orienation)     * recalculate effects     * @param orientation     */    public void getOrientation(BasisCollection orientation)    {        if (!hasOrientation())        {            throw new RuntimeException            ("getting orientaion of soemthing with no orientaion");        }        else        {            recalculate();            orientation.set(this.orientation);        }    }           /**     * @return: very simple string rep of TO- present center position.     * @effects: recalculate effects.     *      * overwrite this method to add more information to toString method for subclasses     */    public String toString()    {        recalculate();        String s = "";        s = s + "Present Center Postion is: " + getCenter() + "\n";        return s;    }       /**  * @return: clone of init orientation  * @effects: recalculate effects  */ protected BasisCollection getInitOrientation() {     if (!hasOrientation())     {         return null;     }     else     {         //recalculate();         return (BasisCollection) initOrientation.clone();     } }         /**     * @requires hasOrientation     * @return actual normal vector of orientation in presence of parental motion     */    protected Vector3d getNormal()    {        if (!hasOrientation())        {            throw new RuntimeException            ("getting orientation of soemthing with no orientaion");        }        recalculate();        return orientation.getNormal();    }    /**     * @requires hasOrientation     * @param normal     * @effects: normal.equals(orientation.normal()) (actual normal vector of orientatoin)     */    protected void getNormal(Vector3d normal)    {        if (!hasOrientation())        {            throw new RuntimeException            ("getting orientaion of soemthing with no orientaion");        }        recalculate();        orientation.getNormal(normal);    }            //Parent get methods        /**     *      * @return true if TO has enclosing parent     */    protected boolean hasParent()    {        return parent!=null;    }         /**     * Possible rep exposure here- careful- make protected?     * @return MODIFIABLE view of this.parent     */    protected TransformableObject getParent()    {        return this.parent;    }          //Children Get methods    /**     *      * @return true if T.O. has children     */    protected boolean hasChildren()    {        if(!heavy)        {        		//No light object can have children- children list is null            return false;        }        return !children.isEmpty();    }        /**     *      * @return number of children     */    protected int getNumberOfChildren()    {        //recalculate();        if (heavy)        {            return children.size();        }        else return 0;    }        /**     * possible rep exposure here     * @requires: this.selfMoving = true     * @return Iterator over a MODIFIABLE view of this.children. For all     *         children, this.child.dirty may be true or false     */    protected Iterator getChildren()    {        if (!heavy)        {            throw new RuntimeException(                    "Trying to get children iterator of an object that cant have children");        }        else        {            return children.iterator();        }    }        /**     * possible rep exposure here     *      * @requires: indxth child exists     * @return: MODIFIABLE view of indxth child     */    protected TransformableObject getChild(int index)    {        if (!heavy || (index < 0)|| (index > getNumberOfChildren() - 1))        {            throw new RuntimeException(                    "Getting a child that doesnt exist with transformable object");        }        else        {            return (TransformableObject) children.get(index);        }    }    //Dirty get methods    /**     *      * @return this.dirty     */    public boolean isDirty()    {        return getRoot().dirty;    }    /**     * @return heavy     */    public boolean isHeavy()    {        return heavy;    }        //Rotation center get methods    /**     *      * @return movingRotationCenter     */    public boolean hasMovingRotationCenter()    {    		return this.movingRotationCenter;    }           //Set methods    /**     * @requires: this can only be called once for any object!     * @effects:      * this.initOrientation.equals(bc);     * this.orientation.equals(bc);      * entire tree becomes dirty     */    protected void setInitOrientation(BasisCollection bc)    {        if (this.initOrientation != null || this.orientation != null)        {            throw new RuntimeException(                    "setOrientation of Transformable object called more than once!");        }        else        {            this.initOrientation = (BasisCollection) bc.clone();            this.orientation = (BasisCollection) bc.clone();        }        this.makeDirty();    }        /**     * @effects: sets clockwise rotation about init axis1, goes into effect upon actual axis1     * when recalculate is called.     *      * entire tree is made dirty     *      * @param angle     */    protected void rotateAboutInitAxis1(double angle)    {        //System.out.println("rotating about normal by: " + angle + "\n");        initTrajectory.setAngle1(angle);        this.makeDirty();    }    /**     * @effects: sets clockwise rotation about init axis2, goes into effect upon actual axis2     * when recalculate is called.     *      * entire tree is made dirty     * @param angle     */    protected void rotateAboutInitAxis2(double angle)    {        //System.out.println("rotating about polar by: " + angle + "\n");        initTrajectory.setAngle2(angle);        this.makeDirty();    }        /**     * @effects: sets clockwise rotation about init axis3, goes into effect upon actual axis3     * when recalculate is called.     *      * entire tree is made dirty     *      * @param angle     */    protected void rotateAboutInitAxis3(double angle)    {        //System.out.println("rotating about azimuthal by: " + angle + "\n");        initTrajectory.setAngle3(angle);        this.makeDirty();    }    	    	/**    	 * @effects: sets all three translations along init basis1, init basis2, init basis3, goes into effect     	 * upon actual bases when recalculate is called    	 *     	 * entire tree is made dirty    	 *     	 * @param shift1    	 * @param shift2    	 * @param shift3    	 */    	protected void setInitTranslation(double shift1, double shift2, double shift3)    	{    	    initTrajectory.setTranslate1(shift1);    	    initTrajectory.setTranslate2(shift2);    	    initTrajectory.setTranslate3(shift3);    	    this.makeDirty();    	}    	       	/**    	 * @effects: sets translation along init basis1, goes into effect     	 * upon actual basis1 when recalculate is called    	 *     	 * entire tree is made dirty    	 *     	 * @param shift1    	 */    	    protected void setInitTranslation1(double shift)    {        initTrajectory.setTranslate1(shift);        this.makeDirty();    }      	/**	 * @effects: sets translation along init basis2, goes into effect 	 * upon actual basis2 when recalculate is called	 * 	 * entire tree is made dirty	 * 	 * @param shift2	 */	    protected void setInitTranslation2(double shift)    {        initTrajectory.setTranslate2(shift);        this.makeDirty();    }	/**	 * @effects: sets translation along init basis3, goes into effect 	 * upon actual basis3 when recalculate is called	 * 	 * entire tree is made dirty	 * 	 * @param shift3	 */    protected void setInitTranslation3(double shift)    {        initTrajectory.setTranslate3(shift);        this.makeDirty();    } 	/**	 * @effects: sets init axis1, goes into effect 	 * upon actual axis1 when recalculate is called	 * 	 * initAxis1.equals(axis)	 * entire tree is made dirty	 * 	 * @param axis	 */       protected void setInitAxis1(Vector3d axis)    {        initTrajectory.setAxis1(axis);        this.makeDirty();    }       /**	 * @effects: sets initAxis2, goes into effect 	 * upon actual axis2 when recalculate is called	 * 	 * initAxis2.equals(axis)	 * entire tree is made dirty	 * 	 * @param axis	 */        	//TODO: get rid of set axis methods?    protected void setInitAxis2(Vector3d axis)    {        initTrajectory.setAxis2(axis);        this.makeDirty();    }    /**	 * @effects: sets initAxis3, goes into effect 	 * upon actual axis3 when recalculate is called	 * 	 * initAxis3.equals(axis)	 * entire tree is made dirty	 * 	 * @param axis	 */        protected void setInitAxis3(Vector3d axis)    {        initTrajectory.setAxis3(axis);        this.makeDirty();    }            /**	 * @effects: sets init axis1, goes into effect 	 * upon actual axis1 when recalculate is called	 * 	 * entire tree is made dirty	 * initAxis1.equals(vector(x,y,z))	 * @param x, y, z	 */       protected void setInitAxis1(double x, double y, double z)    {        initTrajectory.setAxis1(x,y,z);        this.makeDirty();    }        /**	 * @effects: sets init axis2, goes into effect 	 * upon actual axis2 when recalculate is called	 * 	 * entire tree is made dirty	 * initAxis2.equals(vector(x,y,z))	 * 	 * @param x, y, z	 */     protected void setInitAxis2(double x, double y, double z)    {        initTrajectory.setAxis2(x,y,z);        this.makeDirty();    }        /**	 * @effects: sets init axis3, goes into effect 	 * upon actual axis3 when recalculate is called	 * 	 * initAxis3.equals(vector(x,y,z))	 * 	 * entire tree is made dirty	 * 	 * @param x, y, z	 */     protected void setInitAxis3(double x, double y, double z)    {        initTrajectory.setAxis3(x,y,z);        this.makeDirty();    }        /**     * @requires: initBasis1, initBasis2, initBasis3 all stay     * independent of one another     * @effects: initBasis1.equals(b1)     * entire tree is made dirty     * @param b1     */    protected void setInitBasis1(Vector3d b1)    {        initTrajectory.setBasis1(b1);        this.makeDirty();    }    /**     * @requires: initBasis1, initBasis2, initBasis3 all stay     * independent of one another     * @effects: initBasis2.equals(b2)     * entire tree is made dirty     * @param b2     */    protected void setInitBasis2(Vector3d b2)    {        initTrajectory.setBasis2(b2);        this.makeDirty();    }    /**     * @requires: initBasis1, initBasis2, initBasis3 all stay     * independent of one another     * @effects: initBasis3.equals(b3)     * entire tree is made dirty     * @param b2     */    protected void setInitBasis3(Vector3d b3)    {        initTrajectory.setBasis3(b3);        this.makeDirty();    }         //TODO: explain further    /**     * @param pos     * sets initCenter (in the absence of parental motion) to pos     */    protected void setInitPosition(Tuple3d pos)    {        this.initCenter.set(pos);        this.makeDirty();    }       protected void setInitPosition(double x, double y, double z)    {        this.initCenter.set(x,y,z);        this.makeDirty();    }        /**     * @effects: o is appended to this.children,      * this.dirty = true     */    protected void addChild(TransformableObject o)    {        if (heavy)        {            children.add(o);            o.makeDirty();        }        else        {            throw new RuntimeException("Adding a child to an unmoving object!");        }    }        //this is ugly but seems unavoidable!    //required to be called after Transformable object is created...     //If an object is meant to be constructed with children, those children can't    //have their parent field added untill the parent exists- that is    //purpose of this method.         //To use TO, Create a static constructor in any class extending TO, and     //call the private constructor within it, and then call    //giveChildrenParents.     protected void giveChildrenParents()    {        Iterator iter = getChildren();        while (iter.hasNext())        {        		            ((TransformableObject) (iter.next())).setParent(this);        }    }                /**     * @effects: removes children from TO,     *  TO.child.parent = null, TO.child.dirty = true;     *     */    protected void removeChildren()    {        if (heavy)        {            Iterator iter = getChildren();            while (iter.hasNext())            {                TransformableObject to = (TransformableObject)iter.next();                to.makeDirty();                to.setParent(null);            }            children.clear();        }        else        {            throw new RuntimeException("removing a child from a lightwight object!");        }    }    /**     * effects: this.initCenter.equals(to.initCenter)     * this.initTrajectory.equals(to.initTrajectory)     * this.initOrientation.equals(initOrientation)     * this.movginRotationCenter = to.movingRotationCenter     * this.dirty = true     * this.heavy = to.heavy     * @param to     */    public void set(TransformableObject to)    {    		this.heavy = to.heavy;    		this.movingRotationCenter = to.movingRotationCenter;        this.initCenter.set(to.initCenter);        this.makeDirty();        if (heavy)        {            if (this.hasOrientation())            {                this.initOrientation.set(to.initOrientation);            }            this.initTrajectory.set(to.initTrajectory);        }    }            /**     * set center to value of initCenter     * if has trajectory, value of trajectory = value of initTrajectory     * if has orientation, value of orientation = value of initOrientation     * For all TO.children, to.child.reinitialize all     * This method recursively init updates all the way down the tree     *       */    private void reinitializeAll()    {        initCenter.get(this.center);         if (heavy)        {        	//reinitializing orientation            if (hasOrientation())            {                this.orientation.set(this.initOrientation);            }            this.trajectory.set(initTrajectory);             //reinitializing children            Iterator iter = children.iterator();            while (iter.hasNext())            {                TransformableObject child = (TransformableObject) iter.next();                child.reinitializeAll();            }        }    }    /**     * @effects: if this.dirty = true, the effect of all trajectory parameter     *           changes in the tree is calculated. THe trajectory at the root of the tree     *           is applied to the objects below it. Then the trajectories at the next level of depth     *           are applied to the objects below, and so on.      *       */    private void recalculate()    {        if (this.isDirty())        {            TransformableObject root = getRoot();            root.recalculateHelper(); //climbing up to the root first before             //recursing down        }    }    /**     * @requires: intiial recursion is started at root     *     */    private void recalculateHelper()    {        //when at top of tree, reactualize all        reinitializeAll();        if (heavy)        {            Transform3D initT = this.trajectory.getTransform();//this.getTransform();            reactualizeAll(initT, true); //reactualize all cleans things up and            // does the tree walk        }    }    //walks down the tree, applying trajetory transforms.     private void reactualizeAll(Transform3D t, boolean selfTransform)    {        this.updateActual(t, selfTransform);        //checking to make sure we have children        if (heavy)        {            Iterator iter = children.iterator();            while (iter.hasNext())            {                TransformableObject child = (TransformableObject) iter.next();                child.reactualizeAll(t, false);                if (selfTransform)                {                    if (child.heavy)                    {                        Transform3D selfT = child.trajectory.getTransform();                        child.reactualizeAll(selfT, true);                    }                }            }        }        this.dirty = false;    }        /**     * @effects: if heavy,     * 			this.center = t.transform(center);     * 			this.orientation= t.transform(orientation)     * 			this.trajectory = t.transform(trajectory),      * 			but if t is the to's own transform, then t has no effect on     *           the trajectory.     *       */    private void updateActual(Transform3D t, boolean selfTransform)    {        t.transform(this.center); //places the result into the actual center        if(heavy)        {            if (this.hasOrientation())            {                orientation.transformBasis(t);            }            if (!selfTransform)            {                this.trajectory.TransformSelfBy(t);//actual trajectory transformed by t             }        }    }        /**     * @effects: the root booleans dirty is set to true. Subsequent calls to isDirty for any TO     * in the tree return true, regardless of any other TO's dirty boolean. In other words,     *  if the root's dirty boolean is true, and the descendants have dirty booleans that are false,     *  to the user, the user will only see the value of the roots boolean. Purely deals with inner rep.     */    private void makeDirty()    {        TransformableObject root = getRoot();        root.dirty = true;    }        /**       *      * @return: Transformable object at root of tree     */    private TransformableObject getRoot()    {        if(parent!=null)        {            return parent.getRoot();        }        else         {            return this;        }    }        /**     * @requires: does not already have a parent, or o is null     *      * @effects: this.parent = o;     *      *      * This method is only called within giveChildrenParents     */    protected void setParent(TransformableObject o)    {    		if (this.hasParent())    		{    			if(o!=null)    			{    				System.out.println(this);    				System.out.println(this.parent);    				throw new RuntimeException("Calling setParent for a TO with a parent already");   			    			}    		}        parent = o;        this.makeDirty();    }    ////    private Transform3D getTransform()//    {//        if (this.dirty)//        {//            recalculate();//        }//        Transform3D t = trajectory.getTransform();//        return t;//        //return trajectory.getTransform(time);//    }////    private Transform3D getInitTransform()//    {//        return initTrajectory.getTransform();//    }     }