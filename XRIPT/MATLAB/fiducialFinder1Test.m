clear all;

prog_directory = cd;
%Select Image
[FileName, PathName] = uigetfile('*.tif','Select Image');

cd(PathName);

%Load picture data
XRAY_pic = imread(FileName);
cd(prog_directory);

figure
imagesc(XRAY_pic);
colormap gray;
pbaspect('manual');


%choose a point that is inside the circle
[x1,y1] = ginput(1);

xmin = x1-40;
ymin = y1-40;
wid = 80;
hgt = 80;

if xmin <= 0
    xmin = 1;
end
if ymin <= 0
    ymin = 1;
end
xmin
ymin
 
Isegment = double(imcrop(XRAY_pic,[xmin ymin wid hgt]));
[r,c] = size(Isegment); %For future, when size of cropped image may change

%--------------------------------------------------------------------------

%Filter Vertical Lines
IvertFilt = filtVertLines(Isegment);

%Filter Horizontal Lines
Ifiltered = filtHorLines(IvertFilt);

%--------------------------------------------------------------------------

%Spread image intensity so it occupies 0-255, then normalize values between
%0 -- 1
ImNorm = image_normalization(Ifiltered,255);  
ImNorm = ImNorm/255;

%--------------------------------------------------------------------------

%--------------------------------------------------------------------------

%%Median and wiener filtering:
ImedFilt = medfilt2(ImNorm,[3 3]);
ImedFilt = image_normalization(ImedFilt,1);
IwienFilt = wiener2(ImedFilt,[3 3]);
IwienFilt = image_normalization(IwienFilt,1);

%-------------------------------------------------------------------------
%Get Seed point from image segment
[spx,spy] = getSeedPoint(IwienFilt);

%Find best fit snake contour
f = 1-IwienFilt; %Invert image
f0 = gaussianBlur(f,1);
f0 = image_normalization(f0,1);

%Get potential of the circle in question
[px,py] = gradient(f0);

clear x1 y1

t = 0:0.5:6.28;   %0--2pi
%Seed points are spx and spy passed into function
x1 = spx + 3*cos(t);
y1 = spy + 3*sin(t);

[x1,y1] = snakeinterp(x1,y1,2,0.5);

residual = [];
circlePoints = {}; %Row cell array to hold the circlePoints for each iteration
radius = [];
circleCenter = [];
forceRange = [];
x = x1;  y = y1;

EfLow = 2;
k = 1;
    
for extForce = EfLow:0.2:15  %Get Snake data for different external force parameter
    try
        %tic
        for i=1:60        
            [x,y] = snakedeform2(x,y,0.05,0.1,1,extForce,0.15,px,py,5);
            [x,y] = snakeinterp(x,y,2,0.5); 
        end
     
        circlePoints{k,1}(1,:) = x';
        circlePoints{k,1}(2,:) = y';    
        %circleCenter = center of fitted circle
        %radius = radius of fitted circle
        %residual = sqrt(sum(differences between data points and best fit circle^2))
        [circleCenter(k,:),radius(k),residual(k)] = fitcircle(circlePoints{k,1});  
        forceRange(k) = (extForce/5)+(EfLow-0.2);
        k = k+1;    
        clear x y
        %Get new values of x and y to start the next series of iterations
        x = x1; y = y1;
        %toc
    catch %If an error has been generated by the snakes, try a new extForce value
        clear x y
        x = x1; y = y1;
        continue;
    end
    
end

%Filter data for radii >=20 and <= 10-these values are assumed to be in
%error
circCentLarge = [];
circCentSmall = [];
circCentKeep = [];
forcesLarge = [];
forcesSmall = [];
forcesKeep = [];
residueLarge = [];
residueSmall = [];
residueKeep = [];
radiusLarge = [];
radiusSmall = [];
radiusKeep = [];

large = 0;
small = 0;
keep = 0;
for ii=1:length(radius)
    if radius(ii) >= 20
        large = large+1;
        circCentLarge(large,:) = circleCenter(ii,:);
        residueLarge(large) = residual(ii);
        forcesLarge(large) = forceRange(ii);
        radiusLarge(large) = radius(ii);
    elseif radius(ii) <= 10
        small = small+1;
        circCentSmall(small,:) = circleCenter(ii,:);
        residueSmall(small) = residual(ii);
        forcesSmall(small) = forceRange(ii);
        radiusSmall(small) = radius(ii);
    else
        keep = keep+1;
        circCentKeep(keep,:) = circleCenter(ii,:);
        residueKeep(keep) = residual(ii);
        forcesKeep(keep) = forceRange(ii);
        radiusKeep(keep) = radius(ii);
    end
end

%Get minimum residual value from the valid radii range
if ~isempty(residueKeep)
    [minValue,minIndex] = min(residueKeep);
    cx = circCentKeep(minIndex,1);
    cy = circCentKeep(minIndex,2);
    center.x = xmin+cx-1;
    center.y = ymin+cy-1;        
else
    %Return an obviously irrational circle center if no fitted circles were
    %found with radii in the right range
    center.x = -1;
    center.y = -1;
    
end



    







